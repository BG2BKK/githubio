学习王晓华的《算法的乐趣》，首先对现实中的问题进行分析，尝试对问题建模；然后初步确定问题属于哪类范畴，比如穷举搜索，还是分解问题求值，还是求局部/全局最优解；尝试定义问题状态转换。

现在有个农夫过河的问题，农夫带着狼、羊和菜过河，小船只能由农夫来开，农夫只能带一样；如果没有农夫看管，狼会吃羊，羊会吃菜；现在农夫该怎样做，才能够将自己和其他物品一起带到对岸？

我们分析整个问题中有4个主体，农夫、狼、羊和菜；船只能农夫开，所以它可以和农夫看做一体。每个主体有2中状态，在河这边，还是河那边，没有第三种。

站在河边，不论对岸彼岸，农夫每次有2种操作可选，要么带样东西过河，要么只是自己过河。

我们可以定义问题中的状态；如果主体在此岸，状态为0，如果在彼岸，状态为1；用vector<int>表示四个主体{农夫、狼、羊、菜}，访问通过数组下标来访问；因此初始状态是{0,0,0,0}，而他们要到对岸去，最终状态是{1,1,1,1}。那么问题比较明确，通过怎样的操作，能够从初始状态到最终状态呢？

这个问题中状态变化较少，可以用穷举检索的方法找到解，在搜索的过程中通过题中的限制来剪枝优化。初始状态S为{0,0,0,0}，其中农夫状态S[0]，狼S[1]，羊S[2]，菜S[3]。经过一系列转换，经过中间状态S{v1, v2, v3, v4}，最终到达S{1,1,1,1}。

1. 农夫每次只能自己过河，或者带一个
2. 农夫不在时，狼与羊状态不能相同，羊与菜状态也不能相同

还有个限制是，当前状态不能出现在历史状态中。比如说现在达到了农夫和羊在一遍，狼和菜在一遍，状态为{0,1,0,1}，然后农夫到河对岸，状态为{1,1,0,1}，然后农夫再回来{0,1,0,1}，如果这样ABA的来回跳，状态转换就无法继续了。因此需要记录解的历史状态，以便查询

条件1中，农夫可以枚举选择带和自己一边的狼、羊、菜，或者谁都不带，这里就有个循环如下：

```cpp
solution(log_states) {

    vector<int> s = log_states.back();
    if (s is valid) {
        reutrn;
    }
    for (int i=1; i<s.size(); i++) {
        vector<int> cur = s;

        // 1. people takes someone
        {
            cur[0] = 1 - cur[0];
            cur[i] = cur[0];

            log_states.push_back()
            solution(log_states);
            log_states.pop_back();
        }
        // 2. people returns alone
        {
             cur[0] = 1 - cur[0];

             log_states.push_back()
             solution(log_states);
             log_states.pop_back();
        }
    }
}
```

每次进入solution，尾部就是我们插入的最后一个状态S，如果状态是最终状态，那么循环结束；否则，我们接下来的状态转换要在S的基础上来做。接下来农夫开始枚举带谁过河，或者自己过河。最终遍历完所有状态，得到结果。

这一过程中，判断状态cur是否在曾经出现过，是的话不用再继续；判断状态cur是否合法，否则剪枝。判断方法为：

```cpp
// check if s in valid,
bool valid(vector<int>& s) {

    if (s[0] != s[1] && s[1] == s[2]) {         // lang and yang
        return false;
    }

    if (s[0] != s[2] && s[2] == s[3]) {         // yang and cai
        return false;
    }
    return true;
}
```



完整代码如下：

```cpp
#include <iostream>
#include <vector>
#include <deque>
using namespace std;

//ren|lang|yang|cai

bool check(vector<int>& state) {
    for (auto p : state) {
        if (p == 0) {
            return false;
        }
    }
    return true;
}

void print(vector<int>& s) {
    for (auto p : s) {
        cout << p << "\t";
    }
    cout << endl;
}

void print(deque<vector<int>>& q) {
    cout << "=====" << endl;
    for (auto s : q) {
        print(s);
    }
    cout << "=====" << endl;
}

// check s if in history state
bool checkin(deque<vector<int>>& q, vector<int>& s) {
    for (auto e : q) {
        if (e[0] == s[0] && e[1] == s[1] && e[2] == s[2] && e[3] == s[3]) {
            return true;
        }
    }
    return false;
}

// check if s in valid,
bool valid(vector<int>& s) {

    if (s[0] != s[1] && s[1] == s[2]) {         // lang and yang
        return false;
    }

    if (s[0] != s[2] && s[2] == s[3]) {         // yang and cai
        return false;
    }
    return true;
}

void solution(deque<vector<int>> states) {

    vector<int>& s = states.back();
    if (check(s)) {
        print(states);
        return ;
    }

    for (int i=1; i<s.size(); i++) {

        vector<int> cur = s;
        int ret = 1 - cur[0];
        int tmp = cur[i];

        // people takes cur[i]
        if (cur[0] == cur[i]) {
            cur[0] = cur[i] = ret;

            if (!checkin(states, cur) && valid(cur)) {
                states.push_back(cur);
                solution(states);
                states.pop_back();
            }
        }

        // people returns alone
        cur[0] = ret;
        cur[i] = tmp;

        if (!checkin(states, cur) && valid(cur)) {
            states.push_back(cur);
            solution(states);
            states.pop_back();
        }
    }

}

int main() {

    deque<vector<int>> states;
    vector<int> state = {0,0,0,0};          // 0: left, 1: right
    states.push_back(state);

    solution(states);
}
```

