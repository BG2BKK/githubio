cache 在spring中可以有多级，比如某查询接口，作用是根据key从db查询数据，为保证服务质量，可以在整条链路上增加缓存



1. 接口层使用spring提供的concurrentmap简单方式；或者采用google guava的cache；或者采用更新更强的caffine；再配合上Cache注解，可以让业务和缓存代码分离，非常简洁漂亮
2. 本地cache之外，采用redis或者memcache等外部缓存组件，性能也是不错的
3. 此外，可以通过在应用代码中初始化缓存，根据redis查询命令，或者查询db的sql语句，作为缓存的key，将从db中查询的结果缓存起来，也能缓解db后端的压力

前两者缓存，都可以通过注解的方式或单独或配合使用；根据实际业务需求来指定缓存策略。

还应该着重考虑的一点是，当缓存失效时，防止写穿db的防御机制。



1. 最重的方式，当缓存失效，多个请求同时到来，可以访问db前需要争抢锁，抢到锁可以访问db并更新缓存。没有获得锁的请求，等待有人释放锁，再次拿到锁后，先查询缓存，得到结果并返回。这里锁可以设置并发度，既能控制db压力，又能照顾接口响应。guava缓存配置有个sync=true的配置可以做到这点。
2. 对于性能要求十分严格的场景，对锁的使用应该谨慎一些，这里可以根据业务类型，使得缓存能够预热。比如某cache项超时失效时间是60s，在失效前2s就提前去db后端刷新自己，理论上可以缓解cache失效带来的影响。比如ehcache提供了这样的预热机制。


