<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BG2BKK Site</title>
    <link>http://bg2bkk.github.io/</link>
    <description>Recent content on BG2BKK Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 01 Aug 2016 13:26:07 +0800</lastBuildDate>
    <atom:link href="http://bg2bkk.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>redis过期清除机制及应用方法</title>
      <link>http://bg2bkk.github.io/post/redis%E8%BF%87%E6%9C%9F%E6%B8%85%E9%99%A4%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BA%94%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Aug 2016 13:26:07 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/redis%E8%BF%87%E6%9C%9F%E6%B8%85%E9%99%A4%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BA%94%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>

&lt;h2 id=&#34;redis过期清除和淘汰机制:15f341755a194cb3fa2a102ac1aec971&#34;&gt;redis过期清除和淘汰机制&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;过期时间设置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expire key seconds&lt;/li&gt;
&lt;li&gt;该命令设置指定key超时的秒数，超过该时间后，可以将被删除&lt;/li&gt;
&lt;li&gt;在超时之前，如果该key被修改，与之关联的超时将被移除

&lt;ul&gt;
&lt;li&gt;persist key 持久化该key，超时时间移除&lt;/li&gt;
&lt;li&gt;set key newvalue 设置新值，会清除过期时间&lt;/li&gt;
&lt;li&gt;del key   显然会清除过期时间&lt;/li&gt;
&lt;li&gt;例外情况：

&lt;ul&gt;
&lt;li&gt;lpush, zset, incr等操作，在高版本（2.1.3++）之后不会清除过期时间，毕竟修改的不是key本身&lt;/li&gt;
&lt;li&gt;rename 也不会清除过期时间，只是改key名字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;过期处理&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;redis对过期key采用lazy expiration方式，在访问key的时候才判定该key是否过期&lt;/li&gt;
&lt;li&gt;此外，每秒还会抽取volatile keys进行抽样，处理删除过期键&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.marser.cn/archives/87/&#34;&gt;过期键删除策略种类&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事件删除

&lt;ul&gt;
&lt;li&gt;每个键都有一个定时器，到期时触发处理事件，在事件中删除&lt;/li&gt;
&lt;li&gt;缺点是需要为每个key维护定时器，key的量大时，cpu消耗较大&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;惰性删除

&lt;ul&gt;
&lt;li&gt;每次访问时才检查，如果没过期，正常返回，否则删除该键并返回空&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定期删除&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每隔一段时间，检查所有设置了过期时间的key，删除已过期的键&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;redis采用后两种结合的方式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读写一个key时，触发惰性删除策略&lt;/li&gt;
&lt;li&gt;惰性删除策略不能及时处理冷数据，因此redis会定期主动淘汰一批已过期的key&lt;/li&gt;
&lt;li&gt;内存超过maxmemory时，触发主动清理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blueswind8306.iteye.com/blog/2240088&#34;&gt;http://blueswind8306.iteye.com/blog/2240088&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/chenpingzhao/p/5022467.html&#34;&gt;http://www.cnblogs.com/chenpingzhao/p/5022467.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>effective tips in daily work</title>
      <link>http://bg2bkk.github.io/post/effective%20tips%20in%20daily%20work/</link>
      <pubDate>Sun, 24 Jul 2016 16:36:33 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/effective%20tips%20in%20daily%20work/</guid>
      <description>

&lt;h2 id=&#34;sed合并相邻两行:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;sed合并相邻两行&lt;/h2&gt;

&lt;p&gt;从redis中取出一个键的所有内容时，比如hgetall，得到的结果并不是排序好的，类似于这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;11485) &amp;quot;1470347460&amp;quot;
11486) &amp;quot;69&amp;quot;
11487) &amp;quot;1470262350&amp;quot;
11488) &amp;quot;34&amp;quot;
11489) &amp;quot;1470262170&amp;quot;
11490) &amp;quot;68&amp;quot;
11491) &amp;quot;1470242400&amp;quot;
11492) &amp;quot;21&amp;quot;
11493) &amp;quot;1470288030&amp;quot;
11494) &amp;quot;65&amp;quot;
11495) &amp;quot;1470303390&amp;quot;
11496) &amp;quot;54&amp;quot;
11497) &amp;quot;1470205320&amp;quot;
11498) &amp;quot;85&amp;quot;
11499) &amp;quot;1470318330&amp;quot;
11500) &amp;quot;92&amp;quot;
11501) &amp;quot;1470167040&amp;quot;
11502) &amp;quot;1&amp;quot;
11503) &amp;quot;1470281880&amp;quot;
11504) &amp;quot;14&amp;quot;
11505) &amp;quot;1470298140&amp;quot;
11506) &amp;quot;113&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该hash的key为unix时间戳，val为数值，如果想手动看分布的话，需要将相邻两行合并然后排序，在此我们&lt;a href=&#34;http://blog.chinaunix.net/uid-9950859-id-98222.html&#34;&gt;借助sed&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sed &#39;$!N;s/\n/\t/&#39; filename 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;redis分析实例中所有key和单个key的内存占用情况:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;redis分析实例中所有key和单个key的内存占用情况&lt;/h2&gt;

&lt;p&gt;采用&lt;a href=&#34;https://github.com/sripathikrishnan/redis-rdb-tools&#34;&gt;rdb工具&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rdb -c memory /path/to/ab-dump.rdb &amp;gt; memory.csv
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sort进行多重排序:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;sort进行多重排序&lt;/h2&gt;

&lt;p&gt;sort和uniq在文本处理，尤其是日志处理中用的较多的工具，记得当年校招时候准备面试，用到这两个命令，惊为天人，非常shock。在日常工作中，用的也非常多。&lt;/p&gt;

&lt;p&gt;目前有这样的需求，拿到两列数据，第一列是ip，第二列是访问计数，想看一下分布，要求ip要按文本排序，访问计数按数值排序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;221.179.175.109	97
221.179.175.164	101
221.179.175.46	8
221.179.175.164	102
221.179.175.178	78
221.179.175.46	9
221.179.175.109	98
221.179.175.178	79
120.239.141.197	96
221.179.175.70	114
218.202.7.121	70
221.179.175.178	80
218.202.7.121	71
221.179.175.134	83
120.239.141.197	97
221.179.175.46	10
221.179.175.178	81
221.179.175.47	24
120.239.141.197	98
221.179.175.70	115
221.179.175.70	116
120.239.141.197	99
221.179.175.134	84

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.chinaunix.net/uid-25504049-id-3075909.html&#34;&gt;解决方法&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sort -t &#39; &#39; -k1,1 -k2n,2 data


其中 -t &#39; &#39; 指定使用空格分列
-k1,1  指定以第一列为关键字排序
-k2n,2 指定以第二列为关键字做数据排序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/dabingxiaozu/article/details/6213851&#34;&gt;也可以&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sort -k1 -k2n out
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;shell脚本批量处理文本:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;shell脚本批量处理文本&lt;/h2&gt;

&lt;p&gt;善用awk、grep、xargs、bash、sed等工具，可以提高生产力&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep &#39;config.config&#39; . -r | awk -F&#39;:&#39; &#39;{print $1}&#39; | grep &#39;lua$&#39; | xargs sed &amp;quot;s/config.config&#39;)/config.config&#39;).ab/g&amp;quot; -i
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;redis批量删除key:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;redis批量删除key&lt;/h2&gt;

&lt;p&gt;手动清理redis中的key时，很想通过 &lt;strong&gt;&lt;em&gt;del keys&lt;/em&gt;&lt;/strong&gt;* 的方式实现批量删除，而redis却没有提供这样的选项，因此需要借助外部工具&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、sehll 命令行&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;redis-cli keys ip:* | xargs redis-cli del&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2、lua脚本&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;redis-cli eval &amp;ldquo;redis.call(&amp;lsquo;del&amp;rsquo;, unpack(redis.call(&amp;lsquo;keys&amp;rsquo;,&amp;lsquo;ip*&amp;lsquo;)))&amp;rdquo; 0&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;这种方式受限于lua的unpack函数，一次删除的key不能太多&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3、借助客户端&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.redisfans.com/?p=71&#34;&gt;php&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/tuposky/article/details/45364107&#34;&gt;jedis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;unix获取时间戳:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;unix获取时间戳&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;date &#39;+%s&#39;

export timestamp=`date &#39;+%s&#39;`; echo $timestamp

# 标准时间格式转unix时间戳
date -d &amp;quot;2011-03-02 15:00&amp;quot; +%s

# unix时间戳转为标准格式
date -d &#39;1970-01-01 UTC 1299049200 seconds&#39;

# 或者

date -d &amp;quot;@1279592730&amp;quot; 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/hittata/article/details/7640974&#34;&gt;链接&lt;/a&gt;中提到了各种各样的格式，以后写shell脚本就不担心时间戳问题了&lt;/p&gt;

&lt;h2 id=&#34;docker-设置代理下载镜像:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;docker 设置代理下载镜像&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/23111631/cannot-download-docker-images-behind-a-proxy&#34;&gt;在systemd中设置&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;mkdir /etc/systemd/system/docker.service.d&lt;p&gt;&lt;/li&gt;
&lt;li&gt;touch /etc/systemd/system/docker.service.d/http-proxy.conf&lt;p&gt;&lt;/li&gt;
&lt;li&gt;在文件中添加：&lt;p&gt;[Service]&lt;p&gt;Environment=&amp;ldquo;HTTP_PROXY=&lt;a href=&#34;http://proxy.example.com:80/&amp;quot;&#34;&gt;http://proxy.example.com:80/&amp;quot;&lt;/a&gt;&lt;p&gt;&lt;/li&gt;
&lt;li&gt;重启daemon：&lt;p&gt;sudo systemctl daemon-reload&lt;p&gt;&lt;/li&gt;
&lt;li&gt;查看设置状态：&lt;p&gt;sudo systemctl show docker &amp;ndash;property Environment&lt;p&gt;&lt;/li&gt;
&lt;li&gt;重启docker：&lt;p&gt;sudo systemctl restart docker&lt;p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;tested on Ubuntu 16.04&lt;/p&gt;

&lt;h2 id=&#34;用ps查看进程的执行时间:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;用ps查看进程的执行时间&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ps -eo pid,tty,user,comm,stime,etime | grep main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以打印进程的开始时间和执行时间&lt;/p&gt;

&lt;h2 id=&#34;vim下以16进制查看文本文件:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;vim下以16进制查看文本文件&lt;/h2&gt;

&lt;p&gt;vim的功能实在是太强大了，&lt;a href=&#34;http://blog.sina.com.cn/s/blog_4c451e0e0100h4nl.html&#34;&gt;可以以16进制查看文本信息&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;十六进制显示
:%!xxd
正常显示
:%!xxd -r
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;linux获取系统调度时间片长度:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;Linux获取系统调度时间片长度&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;

	int
main(int argc, char *argv[])
{
	int ret, i;  
	struct timespec tp;  
	ret = sched_rr_get_interval(0, &amp;amp;tp);  
	if(ret == -1)  
		printf(&amp;quot;sched_rr_get_interval error.\n&amp;quot;);  
	printf(&amp;quot;The time is %ds:%ldns.\n&amp;quot;, (int)tp.tv_sec, tp.tv_nsec);  
	return 0;  
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./cpu_time_slice.o 
The time is 0s:16000000ns.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见Ubuntu-16.04 64bit的系统进程时间片是16ms&lt;/p&gt;

&lt;h2 id=&#34;c语言中short-int-long内存占用:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;C语言中short、int、long内存占用&lt;/h2&gt;

&lt;p&gt;随着工作年限的增加，很多基本功反而落了下来，甚至开始怀疑short等类型的内存占用问题了呵呵。印象里一直记得int和long类型都是4字节大小啊&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

struct test{
	char *ch1;
	int i;
	long ch2;
} aa;

int main()
{
	printf(&amp;quot;Linux-64Bit-platform\n&amp;quot;);
	printf(&amp;quot;	%lu\n&amp;quot;, (unsigned long)sizeof(aa));
	printf(&amp;quot;	sizeof short : %d\n&amp;quot;, sizeof(short));
	printf(&amp;quot;	sizeof int   : %d\n&amp;quot;, sizeof(int));
	printf(&amp;quot;	sizeof long  : %d\n&amp;quot;, sizeof(long));
	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Linux-64Bit-platform
	24
	sizeof short : 2
	sizeof int   : 4
	sizeof long  : 8

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Linux-32Bit-platform
	24
	sizeof short : 2
	sizeof int   : 4
	sizeof long  : 4

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看来，long和int大小一样已经是32位机器的老黄历了，基础知识还是应该常用常新啊&lt;/p&gt;

&lt;h2 id=&#34;文件操作的线程安全相关-待续:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;文件操作的线程安全相关（待续）&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/29981050/concurrent-writing-to-a-file&#34;&gt;http://stackoverflow.com/questions/29981050/concurrent-writing-to-a-file&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ubuntu关闭键盘和触摸板的方法:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu关闭键盘和触摸板的方法&lt;/h2&gt;

&lt;p&gt;家里的猫就是喜欢趴在笔记本键盘上看你干活，我只能再买一个键盘，然后笔记本键盘留给猫大爷了。&lt;/p&gt;

&lt;p&gt;然而它还喜欢在键盘上跳舞，这样太影响输入了，只能想办法把笔记本键盘关掉。&lt;/p&gt;

&lt;p&gt;在ubuntu下，键盘鼠标触控板都属于xinput设备，可以通过以下命令查看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ xinput  --list
⎡ Virtual core pointer                    	id=2	[master pointer  (3)]
⎜   ↳ Virtual core XTEST pointer              	id=4	[slave  pointer  (2)]
⎜   ↳ SynPS/2 Synaptics TouchPad              	id=16	[slave  pointer  (2)]
⎜   ↳ Rapoo Rapoo Gaming Keyboard             	id=11	[slave  pointer  (2)]
⎜   ↳ RAPOO Rapoo 2.4G Wireless Device        	id=12	[slave  pointer  (2)]
⎜   ↳ Wacom ISDv4 E6 Pen stylus               	id=13	[slave  pointer  (2)]
⎜   ↳ Wacom ISDv4 E6 Finger touch             	id=14	[slave  pointer  (2)]
⎜   ↳ Wacom ISDv4 E6 Pen eraser               	id=18	[slave  pointer  (2)]
⎜   ↳ TPPS/2 IBM TrackPoint                   	id=19	[slave  pointer  (2)]
⎣ Virtual core keyboard                   	id=3	[master keyboard (2)]
    ↳ Virtual core XTEST keyboard             	id=5	[slave  keyboard (3)]
    ↳ Power Button                            	id=6	[slave  keyboard (3)]
    ↳ Video Bus                               	id=7	[slave  keyboard (3)]
    ↳ Sleep Button                            	id=8	[slave  keyboard (3)]
    ↳ Integrated Camera                       	id=9	[slave  keyboard (3)]
    ↳ Rapoo Rapoo Gaming Keyboard             	id=10	[slave  keyboard (3)]
    ↳ AT Translated Set 2 keyboard            	id=15	[slave  keyboard (3)]
    ↳ ThinkPad Extra Buttons                  	id=17	[slave  keyboard (3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到笔记本键盘是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    ↳ AT Translated Set 2 keyboard            	id=15	[slave  keyboard (3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而触控板是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;⎜   ↳ SynPS/2 Synaptics TouchPad              	id=16	[slave  pointer  (2)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他们的id分别是 15和 16，所以采用以下命令关掉就可以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo sudo xinput set-prop 15 &amp;quot;Device Enabled&amp;quot; 0
sudo sudo xinput set-prop 16 &amp;quot;Device Enabled&amp;quot; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;附送shell脚本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

keyboard=`xinput --list | grep AT | awk -F&#39;=&#39; &#39;{print $2}&#39; | awk &#39;{print $1}&#39;`
touchpad=`xinput --list | grep Synaptics | awk -F&#39;=&#39; &#39;{print $2}&#39; | awk &#39;{print $1}&#39;`

function doit() {
	echo &#39;关闭  笔记本键盘&#39;
	`sudo xinput set-prop $keyboard &amp;quot;Device Enabled&amp;quot; 0`			
	echo &#39;关闭  笔记本触摸板&#39;
	`sudo xinput set-prop $touchpad &amp;quot;Device Enabled&amp;quot; 0`
}

doit 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;小于1024的保留端口都有哪些:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;小于1024的保留端口都有哪些&lt;/h2&gt;

&lt;p&gt;我们会遇到如下情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo tcpdump -i any port 1080
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes
15:08:42.421693 IP localhost.55092 &amp;gt; localhost.socks: Flags [.], ack 1960200857, win 342, options [nop,nop,TS val 4687328 ecr 4676064], length 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我想监听1080端口，tcpdump为什么不乖乖显示1080，而是出现个socks呢？（可以通过&lt;strong&gt;&lt;em&gt;-n&lt;/em&gt;&lt;/strong&gt;参数解决）为什么1080是socks，而不是别的呢？&lt;/p&gt;

&lt;p&gt;这是因为低于1024的保留端口大多有自己的名字，他们&lt;a href=&#34;http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml&#34;&gt;由IANA分配&lt;/a&gt;，通常用于系统进程，而我们可以在&lt;strong&gt;&lt;em&gt;/etc/services&lt;/em&gt;&lt;/strong&gt;文件中找到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#
# From ``Assigned Numbers&#39;&#39;:
#
#&amp;gt; The Registered Ports are not controlled by the IANA and on most systems
#&amp;gt; can be used by ordinary user processes or programs executed by ordinary
#&amp;gt; users.
#
#&amp;gt; Ports are used in the TCP [45,106] to name the ends of logical
#&amp;gt; connections which carry long term conversations.  For the purpose of
#&amp;gt; providing services to unknown callers, a service contact port is
#&amp;gt; defined.  This list specifies the port used by the server process as its
#&amp;gt; contact port.  While the IANA can not control uses of these ports it
#&amp;gt; does register or list uses of these ports as a convienence to the
#&amp;gt; community.
#
socks		1080/tcp			# socks proxy server
socks		1080/udp
proofd		1093/tcp
proofd		1093/udp
rootd		1094/tcp
rootd		1094/udp
openvpn		1194/tcp
openvpn		1194/udp
rmiregistry	1099/tcp			# Java RMI Registry
rmiregistry	1099/udp
kazaa		1214/tcp
kazaa		1214/udp
nessus		1241/tcp			# Nessus vulnerability
nessus		1241/udp			#  assessment scanner
lotusnote	1352/tcp	lotusnotes	# Lotus Note
lotusnote	1352/udp	lotusnotes
ms-sql-s	1433/tcp			# Microsoft SQL Server
ms-sql-s	1433/udp
ms-sql-m	1434/tcp			# Microsoft SQL Monitor
ms-sql-m	1434/udp
ingreslock	1524/tcp
ingreslock	1524/udp
prospero-np	1525/tcp			# Prospero non-privileged

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git修改默认分支名:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git修改默认分支名&lt;/h2&gt;

&lt;p&gt;在develop分支改动太大了，导致merge 到master分支时非常被动，这个时候我想，干脆将develop分支作为分支好了。还好碰到&lt;a href=&#34;http://stackoverflow.com/questions/1485578/change-a-git-remote-head-to-point-to-something-besides-master&#34;&gt;stackoverflow的一个帖子&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git branch -m master oldmaster&lt;/li&gt;
&lt;li&gt;git branch -m develop master&lt;/li&gt;
&lt;li&gt;git push -f origin master&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另一个方法是从github的&lt;a href=&#34;https://help.github.com/articles/setting-the-default-branch/&#34;&gt;项目主页上更改&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;编译openssl-1-0-2g:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;编译openssl 1.0.2g&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./config shared -fPIC zlib-dynamic &amp;amp;&amp;amp; make depend -j   &amp;amp;&amp;amp; make -j
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编译nginx-tengine-cpp模块:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;编译nginx/tengine: CPP模块&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure --add-module=../cpp_module  --with-ld-opt=&amp;quot;-lstdc++&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;curl-i-和-i的区别:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;curl -i 和 -I的区别&lt;/h2&gt;

&lt;p&gt;man page:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	-i, --include
		(HTTP) Include the HTTP-header in the output. The HTTP-header includes things like server-name, date of the document, HTTP-version and more...
		
	-I, --head
		(HTTP/FTP/FILE) Fetch the HTTP-header only! HTTP-servers feature the command HEAD which this uses to get nothing but the header of a document. When used on an FTP or FILE file, curl displays the file size and last modification time only.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-i选项会打印出HTTP头部的一些信息，这个选项是curl软件的选项，这些信息本来就是存在的&lt;/p&gt;

&lt;p&gt;-I选项会发送HEAD请求，获取信息&lt;/p&gt;

&lt;h2 id=&#34;linux系统如何将父子进程一起kill掉:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;linux系统如何将父子进程一起kill掉&lt;/h2&gt;

&lt;p&gt;对于普通进程而言，kill掉父进程将会连带着把子进程kill掉；而对于daemon等类型进程而言，kill掉父进程，子进程会被daemon接管，所以如果想父子一起kill掉的话，不能直接kill父进程。&lt;/p&gt;

&lt;p&gt;有&lt;a href=&#34;http://blog.csdn.net/lalaguozhe/article/details/11142855&#34;&gt;两种方法&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;kill &amp;ndash; -PPID&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PPID前面有&lt;strong&gt;&lt;em&gt;-&lt;/em&gt;&lt;/strong&gt;号，可以将父子进程kill掉&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用exec或者xargs来kill掉他们&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dns查询中-域名是否可以有多个cname呢:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;dns查询中，域名是否可以有多个cname呢？&lt;/h2&gt;

&lt;p&gt;不可以
    * &lt;a href=&#34;http://serverfault.com/questions/574072/can-we-have-multiple-cnames-for-a-single-name&#34;&gt;http://serverfault.com/questions/574072/can-we-have-multiple-cnames-for-a-single-name&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;git代理访问:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git代理访问&lt;/h2&gt;

&lt;p&gt;git config &amp;ndash;global http.proxy 10.8.0.1:8118&lt;/p&gt;

&lt;h2 id=&#34;ubuntu操作-挂载-格式化sd卡:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu操作、挂载、格式化SD卡&lt;/h2&gt;

&lt;p&gt;玩树莓派等板子的时候，需要从host机器将os镜像烧进sd卡，然后启动。那么ubuntu如何操作呢？&lt;/p&gt;

&lt;p&gt;fdisk -l命令可以用来查看系统中的存储硬件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;

Disk /dev/sda: 111.8 GiB, 120034123776 bytes, 234441648 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: C27256BB-CE04-48C2-96F4-8F79FAE2AE87

Device     Start       End   Sectors   Size Type
/dev/sda1   2048 234440703 234438656 111.8G Linux filesystem


Disk /dev/sdb: 167.7 GiB, 180045766656 bytes, 351651888 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x42b438a2

Device     Boot     Start       End   Sectors  Size Id Type
/dev/sdb1  *         2048 105887743 105885696 50.5G  7 HPFS/NTFS/exFAT
/dev/sdb2       105887744 187807665  81919922 39.1G 83 Linux
/dev/sdb3       187807744 228767743  40960000 19.5G  7 HPFS/NTFS/exFAT
/dev/sdb4       228769790 351649791 122880002 58.6G  f W95 Ext&#39;d (LBA)
/dev/sdb5       228769792 351649791 122880000 58.6G  7 HPFS/NTFS/exFAT


Disk /dev/sdc: 14.9 GiB, 16021192704 bytes, 31291392 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000

Device     Boot Start      End  Sectors  Size Id Type
/dev/sdc1        8192 31291391 31283200 14.9G  c W95 FAT32 (LBA)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果sd卡（tf卡）通过usb 读卡器接入电脑，则会显示为 /dev/sdc&lt;/p&gt;

&lt;p&gt;如果是标准sd卡（大卡），则会显示为 /dev/mmblck0&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Disk /dev/mmcblk0: 14.9 GiB, 16021192704 bytes, 31291392 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000

Device         Boot Start      End  Sectors  Size Id Type
/dev/mmcblk0p1       8192 31291391 31283200 14.9G  c W95 FAT32 (LBA)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推荐使用USB读卡器，速度较为快一些。&lt;/p&gt;

&lt;h2 id=&#34;lua库文件的加载路径:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;Lua库文件的加载路径&lt;/h2&gt;

&lt;p&gt;Lua 提供一个名为 &lt;a href=&#34;http://www.lua.org/manual/5.1/manual.html#pdf-require&#34;&gt;require&lt;/a&gt; 的函数来加载模块，使用也很简单，它只有一个参数，这个参数就是要指定加载的模块名，&lt;a href=&#34;http://dhq.me/lua-learning-notes-package-and-module&#34;&gt;例如&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&amp;quot;&amp;lt;模块名&amp;gt;&amp;quot;)
-- 或者是
-- require &amp;quot;&amp;lt;模块名&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。&lt;/p&gt;

&lt;p&gt;或者给加载的模块定义一个别名变量，方便调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local m = require(&amp;quot;module&amp;quot;)
print(m.constant)
m.func3()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。&lt;/p&gt;

&lt;p&gt;require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt;  print(package.path)
~/lua/?.lua;/usr/local/share/lua/5.1/?.lua;/home/huang/workspace/luactor/?.lua;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有 LUA_PATH 这个环境变量，也可以自定义设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ export LUA_PATH=&amp;quot;4;;&amp;quot;
huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ lua
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt;  print(package.path)
4;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua;
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，随便加的环境变量&amp;rdquo;4;&amp;ldquo;写在了package.path中。&lt;/p&gt;

&lt;p&gt;而为什么4需要两个&amp;rsquo;；&amp;rsquo;号呢：文件路径以 &amp;ldquo;;&amp;rdquo; 号分隔，最后的 2 个 &amp;ldquo;;;&amp;rdquo; 表示新加的路径后面加上原来的默认路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ export LUA_PATH=&amp;quot;4;&amp;quot;
huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ lua
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt; print(package.path)
4;
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见如果只有一个；号，将只采用这个分号。&lt;/p&gt;

&lt;p&gt;如果找过目标文件，则会调用 package.loadfile 来加载模块。否则，就会去找 C 程序库。搜索的文件路径是从全局变量 package.cpath 获取，而这个变量则是通过环境变量 LUA_CPATH 来初始。搜索的策略跟上面的一样，只不过现在换成搜索的是 so 或 dll 类型的文件。如果找得到，那么 require 就会通过 package.loadlib 来加载它。&lt;/p&gt;

&lt;p&gt;我们也可以在lua代码中&lt;a href=&#34;https://github.com/rtsisyk/luafun&#34;&gt;动态修改package.path变量&lt;/a&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;package.path = &amp;quot;../?.lua;&amp;quot;..package.path
require &amp;quot;fun&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这点对于我们自己的lua project的设置来说无疑是很方便的。
&lt;a href=&#34;http://www.runoob.com/lua/lua-modules-packages.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;cpp调用c函数:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;cpp调用c函数&lt;/h2&gt;

&lt;p&gt;由于CPP在链接时与C不太一样，因此在调用C函数时，&lt;a href=&#34;http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html&#34;&gt;需要做一定处理。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;将C函数的声明房子 &lt;strong&gt;&lt;em&gt;#ifdef __cplusplus&lt;/em&gt;&lt;/strong&gt; 块中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
 
/*.
 * c functions declarations
..*/

#ifdef __cplusplus
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;多少人在猜你机器的密码呢:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;多少人在猜你机器的密码呢&lt;/h2&gt;

&lt;p&gt;VPS在公网就是个待宰的肥肉，都想去登陆，那&lt;a href=&#34;https://plus.google.com/+AlbertSu2015/posts/Uu1vbeJY1Hw&#34;&gt;都谁猜我的IP了呢？&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo grep &amp;quot;Failed password for root&amp;quot; /var/log/auth.log | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;grep的简单使用-与-或-非:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;grep的简单使用，与 或 非&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;或操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep -E &#39;123|abc&#39; filename  // 找出文件（filename）中包含123或者包含abc的行
egrep &#39;123|abc&#39; filename    // 用egrep同样可以实现
awk &#39;/123|abc/&#39; filename   // awk 的实现方式
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;与操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;其他操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，
grep -l pattern files ：只列出匹配的文件名，
grep -L pattern files ：列出不匹配的文件名，
grep -w pattern files ：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），
grep -v pattern files ：不匹配pattern
grep -C number pattern files ：匹配的上下文分别显示[number]行，
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;iptables的简单使用:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;iptables的简单使用&lt;/h2&gt;

&lt;p&gt;其实并不想写iptables相关的内容，因为用的不熟，但是一些常用的命令还是记一下吧&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://linux.cn/article-1586-1.html&#34;&gt;iptables的详细解释&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Linux系统中,防火墙(Firewall),网址转换(NAT),数据包(package)记录,流量统计,这些功能是由Netfilter子系统所提供的，而iptables是控制Netfilter的工具。iptables将许多复杂的规则组织成成容易控制的方式，以便管理员可以进行分组测试，或关闭、启动某组规则。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;https://blog.phpgao.com/vps_iptables.html
http://www.tabyouto.com/bandwagon-vps-for-shadowsocks-was-hacked.html
http://my.oschina.net/yqc/blog/82111?fromerr=VxVIazGW
http://www.vpser.net/security/linux-iptables.html
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 列出所有规则
iptables -L -n

# 更新iptables规则，规则写在/etc/iptables.rules
iptables-restore &amp;lt; /etc/iptables.rules

# 保存iptables规则，规则写在/etc/iptables.rules
iptables-save &amp;gt; /etc/iptables.rules

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是Debian/Ubuntu上iptables是不会保存规则的。&lt;/p&gt;

&lt;p&gt;需要按如下步骤进行，让网卡关闭是保存iptables规则，启动时加载iptables规则：&lt;/p&gt;

&lt;p&gt;创建/etc/network/if-post-down.d/iptables 文件，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
iptables-save &amp;gt; /etc/iptables.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行：chmod +x /etc/network/if-post-down.d/iptables 添加执行权限。&lt;/p&gt;

&lt;p&gt;创建/etc/network/if-pre-up.d/iptables 文件，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
iptables-restore &amp;lt; /etc/iptables.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行：chmod +x /etc/network/if-pre-up.d/iptables 添加执行权限。&lt;/p&gt;

&lt;p&gt;iptables的一些常用规则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#允许ping
iptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想清空的话，先执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sbin/iptables -P INPUT ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sbin/iptables -F
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vps简单的ssh登陆设置:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;VPS简单的ssh登陆设置&lt;/h2&gt;

&lt;p&gt;初次使用VPS，不懂得安全的重要性，直到扣款时候才心疼，这个时候，弱口令，密码登陆什么的，还是都放弃吧，只用ssh登陆，并且换一个自己的端口。&lt;a href=&#34;https://imququ.com/post/bandwagon-vps-and-basicly-usage.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单来说，任何一台主机想登陆VPS的主机都需要有本身的ssh公钥私钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/.ssh/
ssh-keygen -t rsa -C &amp;quot;username@gmail.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后复制~/.ssh/id_rsa.pub中的内容，就是本机的公钥。&lt;/p&gt;

&lt;p&gt;将公钥添加到VPS服务器的/home/username/.ssh/authorized_keys中，本机就能以username用户名登陆VPS了&lt;/p&gt;

&lt;p&gt;然后在/etc/ssh/sshd_config中禁用禁用 VPS 的密码登录和 root 帐号登录，将以下两项改为no&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PasswordAuthentication no
PermitRootLogin no

Port 11111

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随后重启SSH服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo service ssh restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vim删除空行:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;vim删除空行&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;从网页上copy下代码后，发现很多情况下有不想要的空行，非常影响阅读，通过&lt;a href=&#34;http://bbs.chinaunix.net/thread-510754-1-1.html&#34;&gt;vim的正则&lt;/a&gt;可以解决

&lt;ul&gt;
&lt;li&gt;Delete all blank lines (^ is start of line; \s* is zero or more whitespace characters; $ is end of line)&lt;/li&gt;
&lt;li&gt;删除所有空白行(^是行的开始，\s*是零个或者多个空白字符；$是行尾)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;:g/^\s*$/d
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu通过命令设置系统时间:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu通过命令设置系统时间&lt;/h2&gt;

&lt;p&gt;在嵌入式开发中，在pcduino或者rpi板子上安装好linux后，系统时间是UTC时间1970年，对于有些软件来说可能影响安装，所以需要命令行修改date&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo date -s &amp;quot;13 DEC 2015 20:43&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu终端下中文设置:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu终端下中文设置&lt;/h2&gt;

&lt;p&gt;在安装完ubuntu系统后，我们发现中文支持的不好，主要体现在locale的错误，&lt;a href=&#34;http://www.linuxidc.com/Linux/2015-08/122501.htm&#34;&gt;解决方法：&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_PAPER = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_ADDRESS = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_MONETARY = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_NUMERIC = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_TELEPHONE = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_IDENTIFICATION = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_MEASUREMENT = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_TIME = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_NAME = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LANG = &amp;quot;en_US.UTF-8&amp;quot;
    are supported and installed on your system.
perl: warning: Falling back to the standard locale (&amp;quot;C&amp;quot;).

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为中文包没有安装好的缘故，如下命令就可以解决：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;添加简体中文支持
sudo apt-get -y install language-pack-zh-hans language-pack-zh-hans-base

添加繁体中文支持
sudo apt-get -y install language-pack-zh-hant language-pack-zh-hant-base

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果还不行，先观察下locale的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@localhost:~$ locale
locale: Cannot set LC_CTYPE to default locale: No such file or directory
locale: Cannot set LC_MESSAGES to default locale: No such file or directory
locale: Cannot set LC_ALL to default locale: No such file or directory
LANG=en_US.UTF-8
LANGUAGE=
LC_CTYPE=&amp;quot;en_US.UTF-8&amp;quot;
LC_NUMERIC=zh_CN.UTF-8
LC_TIME=zh_CN.UTF-8
LC_COLLATE=&amp;quot;en_US.UTF-8&amp;quot;
LC_MONETARY=zh_CN.UTF-8
LC_MESSAGES=&amp;quot;en_US.UTF-8&amp;quot;
LC_PAPER=zh_CN.UTF-8
LC_NAME=zh_CN.UTF-8
LC_ADDRESS=zh_CN.UTF-8
LC_TELEPHONE=zh_CN.UTF-8
LC_MEASUREMENT=zh_CN.UTF-8
LC_IDENTIFICATION=zh_CN.UTF-8
LC_ALL=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再重新配置下语言包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@localhost:~$  sudo locale-gen &amp;quot;en_US.UTF-8&amp;quot;
Generating locales...
  en_US.UTF-8... done
Generation complete.
huang@localhost:~$ sudo  pip install shadowsocks^C
huang@localhost:~$  sudo locale-gen &amp;quot;zh_CN.UTF-8&amp;quot;
Generating locales...
  zh_CN.UTF-8... done
Generation complete.
huang@localhost:~$ sudo dpkg-reconfigure locales
Generating locales...
  en_US.UTF-8... done
  zh_CN.UTF-8... up-to-date
  zh_HK.UTF-8... done
  zh_SG.UTF-8... done
  zh_TW.UTF-8... done
Generation complete.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般就都能解决&lt;/p&gt;

&lt;h2 id=&#34;linux终端下的颜色设置输出:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;Linux终端下的颜色设置输出&lt;/h2&gt;

&lt;p&gt;Linux终端下，如果有一个彩色的终端，可以明显提升人的阅读兴趣，通过printf的简单设置即可&lt;a href=&#34;http://www.w2bc.com/Article/39141&#34;&gt;实现彩色输出&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;\033[显示方式;前景色;背景色m

    显示方式、前景色、背景色至少一个存在即可。
    格式：\033[显示方式;前景色;背景色m
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;前景色  背景色  颜色
30  40  黑色
31  41  红色
32  42  绿色
33  43  黃色
34  44  蓝色
35  45  紫红色
36  46  青蓝色
37  47  白色


显示方式    意义
0   终端默认设置
1   高亮显示
4   使用下划线
5   闪烁
7   反白显示
8   不可见

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;\033[1;31;40m    &amp;lt;!--1-高亮显示 31-前景色红色  40-背景色黑色--&amp;gt;
\033[0m          &amp;lt;!--采用终端默认设置，即取消颜色设置--&amp;gt;

printf(&amp;quot;\033[1;31;40m&amp;quot;);
printf(&amp;quot;\033[0m&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tsar监控系统负载和nginx运行情况:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;tsar监控系统负载和nginx运行情况&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/alibaba/tsar&#34;&gt;tsar&lt;/a&gt;是阿里巴巴发布的一款能够实时监控系统状态的命令行工具，并且支持第三方模块扩展，其中比较注明的是nginx模块。使用tsar时，可以将系统负载和nginx运行情况同步同时打出，可以用来定位系统瓶颈，所以广受好评。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;tsar -li1&lt;/em&gt;&lt;/strong&gt; 是其最经典的用法，可以将一般我们感兴趣的监控项每秒更新一次并输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Time              ---cpu-- ---mem-- ---tcp-- -----traffic---- --sda---  ---load- 
Time                util     util   retran    bytin  bytout     util     load1   
25/03/16-19:03:30   0.08    10.22     0.00     1.4K    1.2K     0.00     0.33  
25/03/16-19:03:31   0.08    10.21     0.00   424.00  468.00     0.00     0.33   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想使能nginx模块，需要对其进行配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. mkdir /etc/tsar/conf.d
2. touch /etc/tsar/conf.d/nginx.conf

3. 写入如下内容并保存
mod_nginx on

####add it to tsar default output
output_stdio_mod mod_nginx

####add it to center db
#output_db_mod mod_nginx

####add it to nagios send
####set nagios threshold for alert
#output_nagios_mod mod_nginx

#threshold nginx.value1;N;N;N;N;
#threshold nginx.value2;N;N;N;N;
#threshold nginx.value3;N;N;N;N;

表示使能nginx模块，并使用stdio输出

4. tsar -li1

Time              ---cpu-- ---mem-- ---tcp-- -----traffic---- --sda---  ---load- ------------------nginx----------------- 
Time                util     util   retran    bytin  bytout     util     load1      qps      rt  sslqps  spdyps  sslhst   
25/03/16-19:06:19   0.08    11.40     7.14   302.00  546.00     0.00     0.02     1.00    0.00    0.00    0.00    0.00   

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wrk在centos系统上的编译方法:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;wrk在CentOS系统上的编译方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/wg/wrk&#34;&gt;wrk&lt;/a&gt;作为一款可以内嵌lua脚本的，支持多线程的压测工具，受到了广泛欢迎。在高版本CentOS 7上，直接在wrk目录下执行make，可以首先编译deps/luajit，得到deps/luajit/libluajit.a，然而在低版本上，CentOS 6.5系统中，会报一些莫名奇妙的错误。&lt;/p&gt;

&lt;p&gt;解决方法是，查看wrk的Makefile，发现wrk依赖于luajit，那么首先进入deps/luajit编译它，并且是静态编译&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd wrk
cd deps/luajit
make -j24 BUILDMODE=static

cd ../..
make -j24

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rpmbuild环境的快速初始化:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;rpmbuild环境的快速初始化&lt;/h2&gt;

&lt;p&gt;需要将代码打包为CentOS的RPM包时，可以先自己在本地新建一个环境&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. mkdir -p ~/rpmbuild/{SOURCES,BUILD,BUILDROOT,RPMS,SRPMS,SPECS}
2. 将代打包的代码压缩包 software.tar.gz 放入SOURCES文件夹
3. 将 software.spec 放入SPECS文件夹
4. rpmbuild -ba path/to/software.spec 即可
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git记住密码-不用每次都输密码才登入:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git记住密码，不用每次都输密码才登入&lt;/h2&gt;

&lt;p&gt;git有两种方式，一种是ssh方式，配置公钥私钥，对于新手而言还是比较麻烦的；另一种是http方式，这里有一个办法可以让git记住密码，避免每次都需要输入密码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. touch ~/.git-credentials
2. 将  https://{username}:{password}@github.com  写入该文件
3. git config --global credential.helper store  就可以使得git记住密码了
4. 此时查看 ~/.gitconfig，发现多了一项
    
    [credential] 
    helper = store 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;centos系统上某些软件-比如gcc-python等版本过低的解决方案:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;centos系统上某些软件，比如gcc、python等版本过低的解决方案&lt;/h2&gt;

&lt;p&gt;在CentOS Server上，经常会遇到某些软件依赖版本过低的问题，比如CentOS 6.5的python是2.7版本的，gcc是4.2版本的，那么我们如何获得一个干净的、与原版本无冲突的运行环境呢。CentOS系提供了一个叫SCL的工具，可以帮我们实现目的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo wget http://people.centos.org/tru/devtools-1.1/devtools-1.1.repo -P /etc/yum.repos.d
$ sudo sh -c &#39;echo &amp;quot;enabled=1&amp;quot; &amp;gt;&amp;gt; /etc/yum.repos.d/devtools-1.1.repo&#39;
$ sudo yum install devtoolset-1.1
$ scl enable devtoolset-1.1 bash
$ gcc --version
# 通过devtoolset工具可以暂时提高gcc版本，而不更改之前服务器的配置，这个很有效果，高版本的gcc会智能保留symbol。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# CentOS 6.5
sudo yum install centos-release-SCL
sudo yum install python27
scl enable python27 bash
python --version
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu系统上某些软件-比如gcc等版本过高的解决方案:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu系统上某些软件，比如gcc等版本过高的解决方案&lt;/h2&gt;

&lt;p&gt;与CentOS相反，debian系发行版的软件版本都很高，Ubuntu 16.04的gcc 版本已经到了5.2，然而编译一些早期linux内核的话，需要gcc-4.7左右的版本，这时候我们怎么办呢，有两个方法：
* 通过apt安装低版本gcc
    * sudo apt-get install gcc-4.7
    * 在编译linux 内核时， make CC=gcc-4.7 即可
* update-alternatives可以帮忙更改符号链接，指向不同版本的gcc
    * &lt;a href=&#34;http://www.metsky.com/archives/607.html&#34;&gt;参考链接1&lt;/a&gt;
    * &lt;a href=&#34;http://blog.csdn.net/zyxlinux888/article/details/6708775&#34;&gt;参考链接2&lt;/a&gt; &lt;a href=&#34;http://blog.csdn.net/zyxlinux888/article/details/6709036&#34;&gt;附赠&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python的matplotlib库实现绘制图标:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;python的matplotlib库实现绘制图标&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;sudo apt-get install python-matplotlib&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://matplotlib.org/index.html&#34;&gt;参考链接&lt;/a&gt;
&lt;a href=&#34;http://matplotlib.org/examples/index.html&#34;&gt;example&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python使用requests库发送http请求:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;python使用requests库发送http请求&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://cn.python-requests.org/zh_CN/latest/user/quickstart.html#json&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python解析命令行参数-argparse:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;python解析命令行参数：argparse&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.xiayf.cn/2013/03/30/argparse/&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;git比较两次commit的差异:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git比较两次commit的差异&lt;/h2&gt;

&lt;p&gt;通过比较两次commit的代码差异，能够快速理解此次commit的目的，理解作者意图&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git log

&lt;ul&gt;
&lt;li&gt;查看commit历史&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;commit 2279c3f4a8a42e696a0f34e6e9b6289487da92c1
Author: bg2bkk &amp;lt;bg2bkk@gmail.com&amp;gt;
Date:   Sun Mar 13 09:12:26 2016 +0800

    add SO_REUSEADDR和SO_REUSEPORT.md

commit 2b9d85f8427c5ca9e4f9c128c22acd280eb94405
Author: bg2bkk &amp;lt;bg2bkk@gmail.com&amp;gt;
Date:   Sat Mar 12 01:16:00 2016 +0800

    add 采用二级指针实现单链表操作 单链表翻转 删除单链表结点
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;git diff commit 2279c3f4a8a42e696a0f34e6e9b6289487da92c1 2b9d85f8427c5ca9e4f9c128c22acd280eb94405&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git返回强制返回某次提交:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git返回强制返回某次提交&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;git log&lt;/li&gt;
&lt;li&gt;git reset 5f4769a98985b5acfea45462df27830e51a75145 &amp;ndash;hard

&lt;ul&gt;
&lt;li&gt;可见commit号很重要&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;iptables允许端口被外网访问:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;iptables允许端口被外网访问&lt;/h2&gt;

&lt;p&gt;防火墙设置，配置1985端口可以被外网访问&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sudo iptables -A INPUT -m state &amp;ndash;state NEW -m tcp -p tcp &amp;ndash;dport 1985 -j ACCEPT&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcpdump过滤指定标志的packet:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;tcpdump过滤指定标志的packet&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# tcp包里有个flags字段表示包的类型，tcpdump可以根据该字段抓取相应类型的包：
# tcp[13] 就是 TCP flags (URG,ACK,PSH,RST,SYN,FIN)
# Unskilled 32
# Attackers 16
# Pester     8
# Real       4
# Security   2
# Folks      1

#抓取fin包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 1 != 0 &#39; -s0  -w fin.cap -vvv
#抓取syn+fin包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 3 != 0 &#39; -s0  -w syn_fin.cap -vvv
#抓取rst包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 4 != 0 &#39; -s0  -w rst.cap -vvv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://babyhe.blog.51cto.com/1104064/1395489&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看进程的内存占用情况:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;查看进程的内存占用情况&lt;/h2&gt;

&lt;p&gt;用Ternary Search Tree代替Trie Tree后，我想知道我的进程内存占用有多大区别。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ps -e -o &amp;lsquo;pid,comm,args,pcpu,rsz,vsz,stime,user,uid&amp;rsquo; | grep MyDict&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rsz是实际占用内存，单位是KB&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pmap -d pid&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>nodemcu_smart_home</title>
      <link>http://bg2bkk.github.io/post/nodemcu_smart_home/</link>
      <pubDate>Wed, 13 Jul 2016 17:03:29 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/nodemcu_smart_home/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.myelectronicslab.com/tutorial/door-sensor-with-push-notification-using-esp8266-nodemcu/&#34;&gt;智能门锁&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://instapush.im/&#34;&gt;推送服务器instapush&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.myelectronicslab.com/wp-content/uploads/2016/04/my-electronics-lab-InstaPushCode.zip&#34;&gt;智能门锁内含推送服务器端php代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.blynk.cc/&#34;&gt;blynk.cc&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First drag-n-drop IoT app builder for Arduino, Raspberry Pi, ESP8266, SparkFun boards, and others&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/MarsTechHAN/Weplaio&#34;&gt;marsTechHan的天气检测&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://frightanic.com/iot/comparison-of-esp8266-nodemcu-development-boards/&#34;&gt;esp8266开发板的对比&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://dataguild.org/?p=6817&#34;&gt;mqtt简介&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://iotbytes.wordpress.com/wifi-configuration-on-nodemcu/&#34;&gt;nodemcu的wifi配置经&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pradeesi/NodeMCU-WiFi&#34;&gt;src&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/esp8266/comments/3ydxnx/cant_get_esp8266_access_point_to_work_with/&#34;&gt;topic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://nurdspace.nl/ESP8266#Technical_Overview&#34;&gt;esp8266 user guide&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.xue163.com/588880/39187/391875076.html&#34;&gt;服务器和智能硬件的互相通信方案&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;google &amp;lsquo;server push message to  nodemcu&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://postscapes.com/internet-of-things-protocols&#34;&gt;物联网的协议和标准&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://websocket.org/&#34;&gt;websocket官网&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/leytton&#34;&gt;mqtt&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://nodemcu.readthedocs.io/en/master/en/modules/wifi/#wifistagetap&#34;&gt;esp8266的smartconfig&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/txf1984/article/details/51188561&#34;&gt;示例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/p/a852d5ca6a44&#34;&gt;例子&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/SmingHub&#34;&gt;sming hub&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://tuanpm.net/rock-solid-esp8266-wifi-mqtt-restful-client-for-arduino/&#34;&gt;Rock solid esp8266 wifi mqtt, restful client for arduino&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.nyl.io/esp8266-led-arduino/&#34;&gt;8266 mcu&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>postgresql初步上手</title>
      <link>http://bg2bkk.github.io/post/postgresql%E5%88%9D%E6%AD%A5%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Fri, 08 Jul 2016 00:37:41 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/postgresql%E5%88%9D%E6%AD%A5%E4%B8%8A%E6%89%8B/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;sudo apt-get install postgresql&lt;/li&gt;
&lt;li&gt;pip install psycopg2&lt;/li&gt;
&lt;li&gt;su postgres&lt;/li&gt;
&lt;li&gt;pgcli&lt;/li&gt;
&lt;li&gt;create database testdb&lt;/li&gt;
&lt;li&gt;alter user postgres password huang;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>stm32_eclipse_openocd_stlink</title>
      <link>http://bg2bkk.github.io/post/stm32_eclipse_openocd_stlink/</link>
      <pubDate>Wed, 06 Jul 2016 12:51:05 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/stm32_eclipse_openocd_stlink/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;eclipse下载&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;neon &lt;a href=&#34;http://ftp.jaist.ac.jp/pub/eclipse/technology/epp/downloads/release/neon/R/eclipse-jee-neon-R-linux-gtk-x86_64.tar.gz&#34;&gt;http://ftp.jaist.ac.jp/pub/eclipse/technology/epp/downloads/release/neon/R/eclipse-jee-neon-R-linux-gtk-x86_64.tar.gz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;system workbench:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;stlink 驱动&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://erika.tuxfamily.org/wiki/index.php?title=Tutorial:_STM32_-_Integrated_Debugging_in_Eclipse_using_GNU_toolchain&amp;amp;oldid=5474&#34;&gt;http://erika.tuxfamily.org/wiki/index.php?title=Tutorial:_STM32_-_Integrated_Debugging_in_Eclipse_using_GNU_toolchain&amp;amp;oldid=5474&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.st.com/content/st_com/en/products/embedded-software/development-tool-software/stsw-link004.html#&#34;&gt;http://www.st.com/content/st_com/en/products/embedded-software/development-tool-software/stsw-link004.html#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux: &lt;a href=&#34;https://github.com/texane/stlink&#34;&gt;https://github.com/texane/stlink&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;sudo apt-get install autoreconf&lt;/li&gt;
&lt;li&gt;sudo apt-get install libusb-1.0-0 libusb-1.0-0-dev&lt;/li&gt;
&lt;li&gt;make &amp;amp;&amp;amp; make -j &amp;amp;&amp;amp; make install&lt;/li&gt;
&lt;li&gt;sudo ./st-util

&lt;ul&gt;
&lt;li&gt;之前还需要做udev.rules，现在发现不需要&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用法：&lt;a href=&#34;http://erika.tuxfamily.org/wiki/index.php?title=Tutorial:_STM32_-_Integrated_Debugging_in_Eclipse_using_GNU_toolchain&amp;amp;oldid=5474&#34;&gt;http://erika.tuxfamily.org/wiki/index.php?title=Tutorial:_STM32_-_Integrated_Debugging_in_Eclipse_using_GNU_toolchain&amp;amp;oldid=5474&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;arm gcc compiler&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sudo apt-get install gcc-arm-none-eabi&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;插件和eclipse环境配置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;eclipse cdt 插件

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://eclipse.org/cdt/downloads.php&#34;&gt;https://eclipse.org/cdt/downloads.php&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://gnuarmeclipse.sourceforge.net/updates&#34;&gt;http://gnuarmeclipse.sourceforge.net/updates&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gnu arm eclipse plugins的几种安装方法 &lt;a href=&#34;http://gnuarmeclipse.github.io/plugins/install/&#34;&gt;http://gnuarmeclipse.github.io/plugins/install/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gnuarmeclipse.github.io/eclipse/workspace/preferences/&#34;&gt;http://gnuarmeclipse.github.io/eclipse/workspace/preferences/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gnuarmeclipse.github.io/plugins/packs-manager/&#34;&gt;http://gnuarmeclipse.github.io/plugins/packs-manager/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ac6 system workbench: &lt;a href=&#34;http://www.ac6-tools.com/Eclipse-updates/org.openstm32.system-workbench.site/&#34;&gt;http://www.ac6-tools.com/Eclipse-updates/org.openstm32.system-workbench.site/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有了它就可以ac6 debugger了，但是没办法，neon不支持&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.emcu.it/STM32/What_should_I_use_to_develop_on_STM32/stm32f0_linux_dvlpt.pdf&#34;&gt;http://www.emcu.it/STM32/What_should_I_use_to_develop_on_STM32/stm32f0_linux_dvlpt.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何使用eclipse新建工程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以安装以上两个插件后，从eclipse新建ac6工程，下载相应库即可，ac6保证这个好使；&lt;/li&gt;
&lt;li&gt;可以从cube新建工程sw4stm32类型的工程，然后引入SW4STM32工程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何调试工程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;debugger: AC6     普通的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用ac6调试, &lt;a href=&#34;http://www.xlgps.com/article/387805.html&#34;&gt;http://www.xlgps.com/article/387805.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;debugger: hardware debugger configuration&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stm32discovery.nano-age.co.uk/open-source-development-with-the-stm32-discovery/getting-hardware-debuging-working-with-eclipse-and-code-sourcey&#34;&gt;http://stm32discovery.nano-age.co.uk/open-source-development-with-the-stm32-discovery/getting-hardware-debuging-working-with-eclipse-and-code-sourcey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;neon还不支持ac6 debugger，所以只能用后者 &lt;a href=&#34;http://www.openstm32.org/forumthread3023&#34;&gt;http://www.openstm32.org/forumthread3023&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;create debugging configuration&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.openstm32.org/Creating+debug+configuration&#34;&gt;http://www.openstm32.org/Creating+debug+configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;开始debug&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;st-flash 烧录工具 &lt;a href=&#34;https://www.youtube.com/watch?v=HKX12hJApZM&#34;&gt;https://www.youtube.com/watch?v=HKX12hJApZM&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;openocd &lt;a href=&#34;https://www.youtube.com/watch?v=ZeUQXjTg-8c&#34;&gt;https://www.youtube.com/watch?v=ZeUQXjTg-8c&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;./configure &amp;ndash;enable-verbose &amp;ndash;enable-verbose-jtag-io &amp;ndash;enable-parport &amp;ndash;enable-jlink &amp;ndash;enable-ulink &amp;ndash;enable-stlink &amp;ndash;enable-ti-icdi&lt;/li&gt;
&lt;li&gt;make -j &amp;amp;&amp;amp; sudo make install&lt;/li&gt;
&lt;li&gt;openocd -f tcl/board/stm32f4discovery.cfg&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;openocd是debug server，3333端口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;eclipse需要debug configuration&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;eclipse的设置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;代码自动提示：&lt;a href=&#34;http://blog.csdn.net/u012750578/article/details/16811227&#34;&gt;http://blog.csdn.net/u012750578/article/details/16811227&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;elua&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;openocd -f ../../openocd-0.9.0/tcl/board/stm32f429discovery.cfg   -c &amp;quot;init&amp;quot;    -c &amp;quot;reset halt&amp;quot;    -c &amp;quot;sleep 100&amp;quot;    -c &amp;quot;wait_halt 2&amp;quot;    -c &amp;quot;echo \&amp;quot;--- Writing elua_lua_stm32f4discovery.bin\&amp;quot;&amp;quot;    -c &amp;quot;flash write_image erase elua_lua_stm32f4discovery.bin 0x08000000&amp;quot;    -c &amp;quot;sleep 100&amp;quot;    -c &amp;quot;echo \&amp;quot;--- Verifying\&amp;quot;&amp;quot;    -c &amp;quot;verify_image elua_lua_stm32f4discovery.bin 0x08000000&amp;quot;    -c &amp;quot;sleep 100&amp;quot;    -c &amp;quot;echo \&amp;quot;--- Done\&amp;quot;&amp;quot;    -c &amp;quot;resume&amp;quot;    -c &amp;quot;shutdown&amp;quot;

st-flash --reset write elua_lua_stm32f4discovery.bin 0x8000000
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>modern_c&#43;&#43;_现代C&#43;&#43;</title>
      <link>http://bg2bkk.github.io/post/modern_c&#43;&#43;_%E7%8E%B0%E4%BB%A3C&#43;&#43;/</link>
      <pubDate>Sat, 11 Jun 2016 12:27:29 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/modern_c&#43;&#43;_%E7%8E%B0%E4%BB%A3C&#43;&#43;/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://msdn.microsoft.com/zh-cn/library/hh279663.aspx&#34;&gt;现代C++类型系统&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>golang_concurrency_patterns</title>
      <link>http://bg2bkk.github.io/post/golang_concurrency_patterns/</link>
      <pubDate>Wed, 08 Jun 2016 11:32:32 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/golang_concurrency_patterns/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;我自己摸索出来的模型&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/pipelines&#34;&gt;https://blog.golang.org/pipelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;上个链接里的内容非常的golang，我们在讲这段代码非常golang的时候，我们说的是协程、channel以及二者的并发实践；我们在讲某段lua代码非常的lua时候，我们说的是coroutine和metatable；我们在讲某段c代码非常的有c味道的时候，往往说的是指针、多级指针和void灵活指向的类型；我们在讲某段cpp代码非常的c++的时候，我们说的是它的封装、类库和内存模型&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>compare_strings_比较字符串</title>
      <link>http://bg2bkk.github.io/post/compare_strings_%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sun, 05 Jun 2016 22:47:08 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/compare_strings_%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/compare-strings/&#34;&gt;http://www.lintcode.com/zh-cn/problem/compare-strings/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://taop.marchtea.com/02.0.html&#34;&gt;http://taop.marchtea.com/02.0.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://taop.marchtea.com/01.02.html&#34;&gt;http://taop.marchtea.com/01.02.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>insertionSortList_链表插入排序</title>
      <link>http://bg2bkk.github.io/post/insertionSortList_%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 05 Jun 2016 22:27:39 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/insertionSortList_%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>&lt;p&gt;写go并发代码有点疲劳，那就A个题吧。我觉得LintCode上的题目都很不错，有难有易，循序渐进的，随手选一道题来做吧。&lt;/p&gt;

&lt;p&gt;选择了&lt;a href=&#34;http://www.lintcode.com/zh-cn/problem/insertion-sort-list/&#34;&gt;链表插入排序&lt;/a&gt;，写起来不那么容易，但是也有调试的快感，其实对于难题，我们需要做到的是心思缜密、抽丝剥茧一步步实现；对于中等题目，我们需要抓住本质，一击制敌；在编码过程中，心里有时刻有代码执行时间复杂度和空间占用的底，逐渐养成这个习惯；编码过程中同样重要的还有编码风格，如果能够简洁明了的表达程序逻辑，就追求简洁，如果变量较多，需要在变量命名的时候注意甄别，对于写出的代码，尽量追求逻辑清晰风格良好，这是一个程序员的基本素质。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;用插入排序对链表排序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;思路：插入排序的特点是，待排序的节点前面所有节点都是已排序的，同时记录已排序部分的末尾，也就是待排序节点的prev节点，所以每次拿带排序节点依次从头比较，直到比较到自己头上；在比较过程中，如果没有合适的位置，最终比较到自己头上，说明待排序节点可以直接补在已排序节点的后面；如果有合适的位置，就直接break，然后待排序节点从链表取出，prev节点的next指向待排序节点的next，保存当前break处的节点，待排序节点占据该节点位置，并将待排序节点的next指向break处节点，完成插入。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/BG2BKK/daily-programming/blob/master/cpp/insertionSortList.cpp&#34;&gt;完整代码地址&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;codelist&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
 * Definition of ListNode
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *         this-&amp;gt;val = val;
 *         this-&amp;gt;next = NULL;
 *     }
 * }
 */
class Solution { 
	public:
		ListNode *insertionSortList(ListNode *head) {
			// write your code here
			if(!head || !head-&amp;gt;next)
				return head;
			ListNode *sortedHead = head;
			ListNode *prev = head;
			ListNode *node = prev-&amp;gt;next;
			while(node){
				ListNode **p = &amp;amp;sortedHead;
				while(*p!=node){
					if((*p)-&amp;gt;val &amp;gt; node-&amp;gt;val){
						break;
					}
					p = &amp;amp;((*p)-&amp;gt;next);
				}
				if(*p == node){
					prev = node;
					node = node-&amp;gt;next;
				} else {
					ListNode *next = *p;
					*p = node;
					prev-&amp;gt;next = node-&amp;gt;next;
					(*p)-&amp;gt;next = next;
					node = prev-&amp;gt;next;
				}
			}
			return sortedHead;
		}
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>cpp_callable_object_可调用对象</title>
      <link>http://bg2bkk.github.io/post/cpp_callable_object_%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Thu, 02 Jun 2016 10:08:04 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/cpp_callable_object_%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://purecpp.org/?p=108&#34;&gt;http://purecpp.org/?p=108&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>让你的lua代码更加的lua</title>
      <link>http://bg2bkk.github.io/post/%E8%AE%A9%E4%BD%A0%E7%9A%84lua%E4%BB%A3%E7%A0%81%E6%9B%B4%E5%8A%A0%E7%9A%84lua/</link>
      <pubDate>Tue, 31 May 2016 16:22:49 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/%E8%AE%A9%E4%BD%A0%E7%9A%84lua%E4%BB%A3%E7%A0%81%E6%9B%B4%E5%8A%A0%E7%9A%84lua/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;metatable and metamethod&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>hash相关的一些知识</title>
      <link>http://bg2bkk.github.io/post/hash%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Tue, 31 May 2016 15:54:21 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/hash%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;p&gt;面试的时候，面试官问我哈希算法，我表示奇怪，因为，哈希算法，不就那么几个嘛，我们要理解这么多吗？这是一个我完全没有想到的领域啊&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于面试题的一些我的思考</title>
      <link>http://bg2bkk.github.io/post/%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Tue, 31 May 2016 15:22:18 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%88%91%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>&lt;p&gt;说实话我对很多面试题是发怵的，很多题真的觉得好难；有时候自我安慰工作中用不到，太难的算法只是用来锻炼思维和编码能力；然而另一些时候发现由于缺乏相应训练和知识储备，面对工作时由于算法和数据结构能力的缺失导致解决问题时候颇感棘手；所以说，面对算法或者算法相关的面试题，是真能考出程序员的水平的。&lt;/p&gt;

&lt;p&gt;算法作为面试题的重点时，其实考的并不特别难，一来为了对人才有一定区分度，而不是故意筛人，二来面试时间限制太难的算法不能保证完成。理想情况下我们最好能结合实际工作进行算法实践。&lt;/p&gt;

&lt;p&gt;我们需要多想多写多练习，从简单的开始，往难的进发。&lt;/p&gt;

&lt;p&gt;说句不好听的，面试题可谓是千篇一律吧。&lt;/p&gt;

&lt;p&gt;知乎上&lt;a href=&#34;https://www.zhihu.com/question/24964987&#34;&gt;SimonS列出的算法题比较经典&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;针对本科和硕士应届生的算法面试题：

1、假设淘宝一天有5亿条成交数据，求出销量最高的100个商品并给出算法的时间复杂度。

2、给一列无序数组，求出中位数并给出算法的时间复杂度。

3、输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。

4、给出10W条人和人之间的朋友关系，求出这些朋友关系中有多少个朋友圈（如A-B、B-C、D-E、E-F，这4对关系中存在两个朋友圈），并给出算法的时间复杂度。

...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;1、假设淘宝一天有5亿条成交数据，求出销量最高的100个商品并给出算法的时间复杂度。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;思路：对这5亿条数据按照商品id进行哈希，并对哈希值当后几位相同时写到同一文件中，这样相同商品就会写在同一文件中，然后可以对每个文件再细分，从容的进行统计。统计每个商品id的成交量后，如果不能一次load进所有内存，这个时候可以采用堆排序的方式维护小顶堆取出top K；如果能load进内存的话，采用其他排序比如快排就可以取出top K的商品了。对交易记录进行哈希分类的时间复杂度是O(N)，采用小顶堆取出top K个元素的时间复杂度是O(Nlogk)，也就是O(N)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- 5亿条成交记录的话，粗略算来也是50G条左右的记录，无论如何也不能整体的放在内存中；每条记录我们认为关键点就是商品的pid，是一个以字符串形式的长整数，如果字符串不长，商品可以通过长整数比如long long类型就可以表示，如果字符串过长，我们可以考虑采用容量较大的哈希算法计算字符串哈希值；总之我们能用一个特别的值来表示这条记录即可。--&gt;

&lt;ul&gt;
&lt;li&gt;2、给一列无序数组，求出中位数并给出算法的时间复杂度。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;思路：仅仅取出中位数的话，如果对整个数组排序，会显得得不偿失；采用快排中用到的partition方法，选择数组第一个值为哨兵，比它大的数组元素放在数组右边，比他小的放在数组左边；分开后，如果此时该元素的下标index是N/2的话，则它就是中位数，否则如果它的下标小于 N/2，说明中位数在它的右边，那么以该元素为左边界，以原数组右边界为右边界，寻找第N/2 - index大的元素；如果它的下标大于N/2的话，采用相似方法。这种方法的时间复杂度是O(NlgN)，实际上和快排的区别在于去掉了merge操作和不关心部分的排序这两项工作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;3、输入一个整型数组，求出子数组和的最大值，并给出算法的时间复杂度。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;思路：典型的动态规划问题，但是作为算法比较薄弱的我，选择先从本办法入手&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;4、给出10W条人和人之间的朋友关系，求出这些朋友关系中有多少个朋友圈（如A-B、B-C、D-E、E-F，这4对关系中存在两个朋友圈），并给出算法的时间复杂度。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;思路：无向图&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>effective tips about tcp ip on Linux</title>
      <link>http://bg2bkk.github.io/post/all%20stuff%20I%20know%20about%20TCP&amp;IP/</link>
      <pubDate>Mon, 30 May 2016 13:58:17 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/all%20stuff%20I%20know%20about%20TCP&amp;IP/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&#34;&gt;Linux内核参数注释&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tonydeng.github.io/2015/05/25/linux-tcpip-tuning/&#34;&gt;TCP参数注释及调优&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;man tcp&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://network.51cto.com/art/201412/459352.htm&#34;&gt;内核为tcp维护的四个定时器&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;重传定时器

&lt;ul&gt;
&lt;li&gt;用于重传没有收到确认的报文；在发送报文时启动重传定时器，如果在定时器时间内收到确认，则撤销定时器；若在收到确认前已经超时，则重传报文并复位定时器。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;坚持定时器

&lt;ul&gt;
&lt;li&gt;当接收方的接收通告窗口是0时，会向发送方发送零窗口报文段；稍后接收方窗口不为0时，会向发送方发送窗口更新报文（非0报文段）；如果发送方没有收到这个报文，则一直会认为接收方还是窗口为0所以继续等待；而接收方此时并不知道这个报文丢失，所以处于等待发送状态；通信双方陷入了死锁状态&lt;/li&gt;
&lt;li&gt;因此TCP为每个连接设置坚持定时器，当发送方收到零长窗口的包时，会启动该定时器；当该定时器到期，发送方会发送探测报文段（只有一个字节，有序号，但是该序号永远不需要确认，也会被忽略掉），探测报文提醒接收端，问问是不是还是零长窗口&lt;/li&gt;
&lt;li&gt;坚持计时器的初始时长是重传时间；第一次探测报文发出，如果没有收到接收端的窗口更新响应，则在坚持计时器超时后，复位该计时器，计时时间加倍，然后发送新的探测报文，重复这个过程；直到定时器时长超过60s为止，开始每60s重复一次。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;保活定时器

&lt;ul&gt;
&lt;li&gt;保活定时器是TCP的keepalive设置；如果客户端故障，链路上没有数据，而服务端不能一直等待，所以需要保活定时器。服务端每次收到对端报文，都会重置保活定时器，默认是7200s，之后再每隔75s重复发送探测报文，连续10次没有回应的话就放弃这个连接。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2MSL定时器

&lt;ul&gt;
&lt;li&gt;第一种情况：被动关闭方发出FIN包并将状态从CLOSE_WAIT转换到LAST_ACK后，主动关闭方从FIN_WAIT2转到TIME_WAIT状态，并回复ACK；这个ACK到达接收方最大需要一个MSL时间，接收方收到ACK后，可以进入CLOSED状态；而如果接收方没有收到ACK，则会认为发送方可能没有收到刚才发的FIN包，所以会从新发送FIN包，这个FIN包到达主动关闭方需要一个MSL时间；因此，如果主动关闭方能等待2个MSL时间，可以在应付被动关闭方再次发送过来的FIN包并回复ACK，保证二者都能进入CLOSED状态&lt;/li&gt;
&lt;li&gt;第二种情况：由于等待了2个MSL时间，之前双方发送的报文都会消失不见，避免下一个采用同样地址和端口的新连接遇到这些不速之客；否则如果等待时间短，新连接可以很快使用这个端口和地址，遇到之前的FIN包什么的，造成误解。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[tcp的超时重连机制]()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tcp_syn_retries&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Number of times initial SYNs for an active TCP connection attempt will be retransmitted. Should not be higher than 127. Default value is 6, which corresponds to 63seconds till the last retransmission with the current initial RTO of 1second. With this the final timeout for an active TCP connection attempt will happen after 127seconds.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于一个活跃的TCP连接来说，SYN报文的重传次数。这个次数应该小于127，默认是6次，初始RTO是1s，这意味着在63s后最后一次重传，所以在第127s的时候这个tcp连接会超时o&lt;/p&gt;

&lt;p&gt;我们将会在1s、2s、4s、8s、16s、32s、64s进行重传&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;rto and retransmission&#34;&gt;tcp的报文超时重传机制&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;google &amp;lsquo;tcp 超时处理&amp;rsquo;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6298&#34;&gt;computing tcp&amp;rsquo;s retransimission timer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;内核有两个重要的超时重传选项&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tcp_retries1 - INTEGER
	This value influences the time, after which TCP decides, that
	something is wrong due to unacknowledged RTO retransmissions,
	and reports this suspicion to the network layer.
	See tcp_retries2 for more details.

	RFC 1122 recommends at least 3 retransmissions, which is the
	default.

tcp_retries2 - INTEGER
	This value influences the timeout of an alive TCP connection,
	when RTO retransmissions remain unacknowledged.
	Given a value of N, a hypothetical TCP connection following
	exponential backoff with an initial RTO of TCP_RTO_MIN would
	retransmit N times before killing the connection at the (N+1)th RTO.

	The default value of 15 yields a hypothetical timeout of 924.6
	seconds and is a lower bound for the effective timeout.
	TCP will effectively time out at the first RTO which exceeds the
	hypothetical timeout.

	RFC 1122 recommends at least 100 seconds for the timeout,
	which corresponds to a value of at least 8.

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;tcp_retries1

&lt;ul&gt;
&lt;li&gt;在发生超时，tcp没有收到报文ack的情况下，会进行重传；重传次数取决于该选项，默认是3次；初次重传时间间隔是0.2s，每次重传的时间间隔加倍，0.2、0.4、0.8、1.6、3.2s&lt;/li&gt;
&lt;li&gt;超过这个时间后，则认为发生了超时，向网络层报告这个怀疑，底层的IP和ARP开始接管，去寻找所要连接的对端机器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;tcp_retries2

&lt;ul&gt;
&lt;li&gt;当RTO超时重传，仍然没有被回复确认包时。给定一个值N，一个假想的TCP连接会随着初始RTO时间进行指数增长补偿，重传N次，在第N+1次时连接被干掉。&lt;/li&gt;
&lt;li&gt;默认值是15次，即924.6s，这是一个有效超时的下限；TCP将在超出这个时间后的第一个RTO中超时；&lt;/li&gt;
&lt;li&gt;RFC1122建议至少这个值是100s，就是说重传8次&lt;/li&gt;
&lt;li&gt;关于RTO的计算，参考RFC和以下链接：

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.orczhou.com/index.php/2011/10/tcpip-protocol-start-rto/&#34;&gt;RTO和RTO在linux上的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pagefault.info/?p=430&#34;&gt;RTO的计算方法一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://perthcharles.github.io/2015/09/06/wiki-rtt-estimator/&#34;&gt;RTO的计算方法二&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://weibo.com/p/1001603821691477346388&#34;&gt;RTO的修改方法&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;rfc1323&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.gesha.net/archives/568/&#34;&gt;格式较好的地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://perthcharles.github.io/2015/09/07/wiki-tcp-retries/&#34;&gt;聊一聊重传次数&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;值得一看，目前我对下文还有疑问，并且认为超时时间只和retries2有关。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   如果RTT较大，比如RTO初始值计算得到的是1000ms
   那么根本不需要重传15次，重传总间隔就会超过924600ms。
   比如我测试的一个RTT=400ms的情况，当tcp_retries2=10时，仅重传了3次就放弃了TCP流
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    * RTO_MIN是动态的一个值
&amp;lt;!-- * 超时后，对端发送RST包，终止连接；connect返回结果是Connection time out 110 --&amp;gt;

* [导致TCP重传的情况](http://www.voidcn.com/blog/gogokongyin/article/p-5803363.html)
    * 报文中途被丢弃，或者ttl到期
    * 报文的ACK在中途丢失
    * 接收端异常，并不发送ACK给发送端
* 判断一个报文是重传报文
    * 序列号突然下降。由于是累计确认的，某个数据包丢失的话，后面的数据包都不会被确认接收；所以序列号下降很有可能是被重传的报文
    * 如果某一时刻出现两个序列号、长度等相同的包，则其中一个包肯定是重传的
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/russell_tao/article/details/18711023&#34;&gt;TCP连接占用内存大小&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;tcp_rmem min mid max 单个TCP连接的读内存占用，系统限制；单位是byte，大小是几KB到十几MB&lt;/li&gt;
&lt;li&gt;tcp_wmem min mid max 单个TCP连接的写内存占用&lt;/li&gt;
&lt;li&gt;tcp_mem min mid max 系统中tcp整体内存使用，单位是4k或者8k大小的页&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SO_SNDBUF和SO_RCVBUF可以基于setsockopt来限制单个tcp的读写缓存，但是会受限于上述的限制；高于或者低于限制时，会被替换&lt;/p&gt;

&lt;p&gt;读写缓存用于缓存对端的TCP报文，读缓存用于缓存两种报文：一种是无序的落在接收滑动窗口中的TCP报文，等待有序报文；另一种是有序报文，但是没有来得及被应用程序读取的TCP报文；写缓存也一样&lt;/p&gt;

&lt;p&gt;读写缓存不是固定的，是在使用中根据使用情况分配的；如果TCP连接非常清闲，读写缓存的大小会降到0；而如果TCP连接非常繁忙，以读缓存为例，如果缓存报文超过缓存大小，则新来报文将被丢弃；持续一段时间后，将向对端发送接收窗口为0的报文&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/&#34;&gt;TCP长连接&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/apn172/article/details/8030230&#34;&gt;SO_KEEPALIVE套接口选项&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SO_KEEPALIVE保持连接检测对方主机是否崩溃，如果2小时内该socket在任一方向都没有数据交换，TCP自动发送给对方一个存活探测分节（keepalive probe）&lt;/li&gt;
&lt;li&gt;存活探测分节是一个对方必须响应的TCP分节，返回有三种情况：

&lt;ul&gt;
&lt;li&gt;对方接收一切正常：以期望的ACK响应&lt;/li&gt;
&lt;li&gt;对方已崩溃并已重新启动：以RST响应，socket错误为ECONNRESET，socket被关闭&lt;/li&gt;
&lt;li&gt;对方无任何响应：开始根据tcp_keepalive_time设置的重传次数开始重传，相隔75s一次，默认9次,11分钟多之后放弃。socket错误是ETIMEOUT，socket被关闭。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;因此如果我们使用系统的保活探测机制，可能在2小时之后才能感知到tcp连接不存在。（方法是设置SO_KEEPALIVE为1）&lt;/li&gt;
&lt;li&gt;所以可以通过setsockopt来设置这个保活机制，TCP_KEEPIDLE、TCP_KEEPINTVL和TCP_KEEPCNT，可以让时间小一点。&lt;/li&gt;
&lt;li&gt;默认设置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;net.ipv4.tcp_keepalive_intvl = 75&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_keepalive_probes = 9&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_keepalive_time = 7200&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://xuelinf.github.io/2016/03/09/TCP-IP-%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB1/&#34;&gt;传输层协议 TCP/UDP&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TCP连接的保活和异常检测&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/apn172/article/details/8034236&#34;&gt;TCP通讯时对侧主机崩溃或者网络异常的退出&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果链路空闲，此时如果是系统的保活机制，空闲7200s后开始发送探测报文，每隔75s发送一次，共持续9次；那么我们可能需要在2小时之后才能发现这个tcp连接断开，这是不可想象的&lt;/p&gt;

&lt;p&gt;此时tcp的其他机制可以起作用：&lt;a href=&#34;rto and retransmission&#34;&gt;tcp超时重传机制&lt;/a&gt;。tcp_retries2参数和TCP_RTO_MIN共同确定的超时时间，如果tcp_retries2是15的话，这个时间是924.6s；如果设置为8，则是100s左右；设置为5的话，46.5s左右就能检测出超时了。
    因此在本地网络正常，对侧网络断开或者对侧主机崩溃时，发出探测包，此时本地socket正常，所以写操作没有问题；如果该报文在tcp_retries2设置的超时时间后没有回应，则判断超时，可以关闭socket了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* [TCP保活报文](http://www.netis.com/flows/2012/11/01/tcpkeepalive/)
    * 保活探测报文是将最近TCP报文的序号减1，并设置1个byte，payload为00的数据报文
    * 保活回复报文将是对其的回应
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/wy5761/article/details/17232495&#34;&gt;深入理解socket网络异常&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端连接了服务端未开放未监听的端口

&lt;ul&gt;
&lt;li&gt;这种情况下服务端会对收到的SYN回应一个RST（RFC793）；客户端收到RST后终止连接，进入CLOSED状态；connect返回ECONNREFUSED 111错误，错误信息：connect refused&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;客户端与服务端之间网络不通&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;connect返回主机不可达

&lt;ul&gt;
&lt;li&gt;如果给出的是一个不可访问的地址，比如不存在的本地网络地址，或者DNS解析失败时，会返回这个错误。在Linux上，错误码是EHOSTUNREACH 113，错误信息：No route to host&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;connect返回连接超时

&lt;ul&gt;
&lt;li&gt;连接超时，客户端的SYN包消失，或者没有收到ACK，就会超时重传SYN；重传间隔时间是1s、2s、4s、8s、16s、32s，默认为6次，第6次SYN会经过64s后超时；也就是说127s后，connect返回ETIMEDOUT&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通信过程中会遇到哪些问题呢：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通信双方之间网络断开，双方也不互相发送数据

&lt;ul&gt;
&lt;li&gt;双方都对网络断开无感知，在没有SO_KEEPALIVE的情况下，双方都会保持ESTABLISHED&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;网络断开，一方给另一方发送数据

&lt;ul&gt;
&lt;li&gt;首先接收方是对网络断开无感知的；理论上讲发送方在重传一定次数后，报超时错误；而实际上，可能发送方会显示发送成功，但接收方一定没有收到数据，原因可能是：

&lt;ul&gt;
&lt;li&gt;写在本机的TCP写缓存中；要么缓存写满后不能再往缓存中写数据，向客户端报错，当然这种情况比较少见；更多情况是写缓存中有一定数据后，启动发送，多次重传后报超时错误&lt;/li&gt;
&lt;li&gt;缓存在本机网络的某个NAT的缓存中，由NAT回复了ACK包&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;因此这里需要说的是，并不是TCP显示发送成功，对方就一定能收到；这个时候只是内核或者本机所处网络的NAT收到了应用程序的数据&lt;/li&gt;
&lt;li&gt;TCP可以保证的是可靠、有序的传输，这个意思是TCP保证收到有序数据包时可以保证可靠传输，而不是发送成功数据包时可靠传输&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;网络断开，一方等待另一方发送数据&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;等待的接收方是不能感知到网络已断开的，如果采用阻塞型的read系统调用等，会一直阻塞下去；当有SO_KEEPALIVE设置时，可以依赖系统的keepalive机制；应用程序可以设置超时时间来确保read不要被永久阻塞&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TCP协议栈在各平台的实现不尽相同，在Linux下，Ctrl+C结束程序，协议栈会发送close，而Windows会发送RST段；如果没有调用close而结束，Linux会发送FIN包，而Win会发送RST包&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;crash的一端发送FIN包，相当于调用close，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;未崩溃的一方继续 接收 数据

&lt;ul&gt;
&lt;li&gt;Linux上，当对端crash后，相当于调用close，会发送FIN包；那么在这个tcp连接上读取数据的接收方，read系统调用会立刻返回失败&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;未崩溃的一方继续 接收 数据

&lt;ul&gt;
&lt;li&gt;对方crash的时刻，tcp连接不会立刻感知；第一次write该tcp连接，可以写成功；而当这次数据包发送到对端时，由于应用程序crash，不论有没有重启，对端都会发送RST包；再次调用write会返回-1，错误码是EPIPE 32，错误信息是Broken Pipe；应用程序会收到SIGPIPE信号，崩溃，没有coredump文件产生（可以通过忽略SIGPIPE避免这个问题）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;crash的一端发送RST包&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;未崩溃的一方继续 接收 数据

&lt;ul&gt;
&lt;li&gt;调用recv会返回-1，错误码ECONNRESET，错误信息 Connection reset by peer&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;未崩溃的一方继续 发送 数据

&lt;ul&gt;
&lt;li&gt;调用send会返回-1，错误码ECONNRESET，错误信息 Connection reset by peer&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;crash的一端没有发送RST或者FIN包&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;调用recv的话会一直阻塞&lt;/li&gt;
&lt;li&gt;调用send的话会尝试重传直到超时&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可见对端崩溃时，本端如何感知，取决于对端是否发送RST包&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc793&#34;&gt;RFC 793&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/wy5761/article/details/17244061&#34;&gt;RST包的产生&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://yaowhat.com/2014/07/28/tcp-rst.html&#34;&gt;向不存在的端口发起连接，对方回复RST&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一些延迟的包，比如旧的SYN包的副本，导致连接无法正常建立&lt;/li&gt;
&lt;li&gt;程序异常终止，有的系统会发送RST&lt;/li&gt;
&lt;li&gt;设置了SO_LINGER选项支持异常关闭，并调用close，会发送RST包&lt;/li&gt;
&lt;li&gt;已经关闭的端口收到了数据，反馈回一个RST包

&lt;ul&gt;
&lt;li&gt;这就是对端crash后，第一次本端向crash方发送数据是可以写成功的，但是当数据到达crash方后，crash已经是关闭了的，所以会回复RST，这个时候tcp就会出错，Broken Pipe&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/wy5761/article/details/17244061&#34;&gt;RST包的处理方式&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Linux-2.6.18源码：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/* When we get a reset we do this. */
static void tcp_reset(struct sock *sk)
{
	/* We want the right error as BSD sees it (and indeed as we do). */
	switch (sk-&amp;gt;sk_state) {
		case TCP_SYN_SENT:
			sk-&amp;gt;sk_err = ECONNREFUSED;
			break;
		case TCP_CLOSE_WAIT:
			sk-&amp;gt;sk_err = EPIPE;
			break;
		case TCP_CLOSE:
			return;
		default:
			sk-&amp;gt;sk_err = ECONNRESET;
	}

	if (!sock_flag(sk, SOCK_DEAD))
		sk-&amp;gt;sk_error_report(sk);

	tcp_done(sk);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;* 当本端这个tcp连接处于TCP_SYN_SENT状态，也就是说本地主动发起连接，缺不幸收到了RST包，这个时候会向应用程序报告ECONNREFUSED连接被拒绝错误
* 当本地这个tcp处于TCP_CLOSE_WAIT状态，就是说本地从ESTA状态收到对方的FIN包后转为CLOSE_WAIT状态时，对端已经关闭了；如果这个时候本地仍然继续向对端发送数据，对端会返回一个RST包，这就导致程序进入这个case分支，因此向上层应用程序报EPIPE错误
* 默认清空下错误码都是ECONNRESET，connection reset by peer了。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;TCP连接中的一些常见的“常数”&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mss 1460

&lt;ul&gt;
&lt;li&gt;以太网的MTU是1500bytes，而IP头是20bytes，TCP头部是20bytes，所以很多时候mss是1460bytes，这个比较常见&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;win 5792

&lt;ul&gt;
&lt;li&gt;在tcp初始化后，接收窗口大小会被设置成4个mss大小，在linux3.0之后是10个mss大小；&lt;/li&gt;
&lt;li&gt;以4个mss大小为例，由于有的时候tcp的头部中option字段可能会带有时间戳，头部额外占用12字节，所以初始窗口大小是 4 * (1460 - 12) = 5792大小&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;broken pipe相关的问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>consistent_hash_一致性哈希算法的实现</title>
      <link>http://bg2bkk.github.io/post/consistent_hash_%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 27 May 2016 13:46:13 +0800</pubDate>
      
      <guid>http://bg2bkk.github.io/post/consistent_hash_%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/coser/archive/2011/11/27/2265134.html&#34;&gt;http://www.cnblogs.com/coser/archive/2011/11/27/2265134.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://my.oschina.net/u/90679/blog/188750&#34;&gt;http://my.oschina.net/u/90679/blog/188750&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>