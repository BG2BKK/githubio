<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on BG2BKK Site</title>
    <link>https://bg2bkk.github.io/post/</link>
    <description>Recent content in Posts on BG2BKK Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 23 Aug 2016 19:52:25 +0800</lastBuildDate>
    <atom:link href="https://bg2bkk.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>C&#43;&#43;基础知识学习</title>
      <link>https://bg2bkk.github.io/post/cpp_basis/</link>
      <pubDate>Tue, 23 Aug 2016 19:52:25 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/cpp_basis/</guid>
      <description>

&lt;h2 id=&#34;static和const关键字各自的作用:2404ccd5838a6732564bda89dd9448a6&#34;&gt;static和const关键字各自的作用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;static关键字&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在函数体内，static变量只分配一次，作用域范围也在该函数体内；当下次调用该函数时，该值保持不变&lt;/li&gt;
&lt;li&gt;模块内的static变量的作用域是模块内&lt;/li&gt;
&lt;li&gt;类的static变量属于整个类，而不是某个对象，所有对象都共有这一份拷贝&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;const关键字&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义常量；首次定义必须初始化，之后不能赋值&lt;/li&gt;
&lt;li&gt;函数声明时，用const修饰形参，可以保证不被函数体修改&lt;/li&gt;
&lt;li&gt;可以修饰类的成员函数，保证其返回值不为“左值”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;拷贝构造函数和赋值构造函数:2404ccd5838a6732564bda89dd9448a6&#34;&gt;拷贝构造函数和赋值构造函数&lt;/h2&gt;

&lt;p&gt;C++的拷贝构造函数、重载赋值构造函数，以及析构函数，属于C++复制控制的范畴&lt;/p&gt;

&lt;p&gt;如果没有手动实现，编译器会自动生成一个；编译器会自动生成以下四个成员函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1. 构造函数&lt;/li&gt;
&lt;li&gt;2. 析构函数&lt;/li&gt;
&lt;li&gt;3. 拷贝构造函数&lt;/li&gt;
&lt;li&gt;4. 赋值构造函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
class String {
public:
	String(const char *);			// 构造函数
	String(const String &amp;amp;other);	// 拷贝构造函数
	String &amp;amp; operator=( const String &amp;amp;other); // 赋值构造函数
	~String();						// 析构函数
private:
	char *m_data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有手动实现，则会替代编译器的行为；除了析构函数，析构函数用于完成对象的释放操作，即使我们手动实现，编译器也会实现一份，这时析构函数可以让我们用来释放动态分配的内存.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;拷贝构造函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String::String(const String &amp;amp;other) {
	int len = strlen(other.m_data);
	m_data = new char[len + 1];
	strcpy(m_data, other.m_data);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;* 如下几种情况下，拷贝构造函数被调用:
    * 1. 定义新对象，并用已有对象初始化新对象：即 String obj = other，或者 String obj(other)时，此时String(const String &amp;amp;other)被调用
    * 2. 对象作为参数传递时，函数将建立对象的临时拷贝
    * 3. 对象作为函数的返回值时，函数建立临时拷贝，并将其返回
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;赋值构造函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String &amp;amp; operator=(const String &amp;amp;other) {
	if( this == &amp;amp;other)
		return *this;
	delete []m_data;

	int len = strlen(other.m_data);
	m_data = new char[len + 1];
	strcpy(m_data, other.m_data);

	return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;* 赋值构造函数的用法
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String obj;
obj = other;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;* 拷贝构造函数
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String obj = other;   //或者
String obj(other);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在前者的&lt;strong&gt;&lt;em&gt;obj = other&lt;/em&gt;&lt;/strong&gt; 和后者的&lt;strong&gt;&lt;em&gt;String obj=other&lt;/em&gt;&lt;/strong&gt;不同，前者表示obj是一个未初始化的对象，通过&lt;strong&gt;&lt;em&gt;=&lt;/em&gt;&lt;/strong&gt;进行赋值，后者中的&lt;strong&gt;&lt;em&gt;=&lt;/em&gt;&lt;/strong&gt;是使用other对obj进行初始化。&lt;/p&gt;

&lt;p&gt;在赋值构造函数中，&lt;strong&gt;&lt;em&gt;=&lt;/em&gt;&lt;/strong&gt;缺省操作是将成员变量的值赋值，这时函数成员的旧值自然被丢弃，比如指针被赋予新值，旧值丢弃；然而指针旧值指向的内存却并未释放；因此包含动态分配成员的类提供拷贝构造函数外，还应该考虑重载&lt;strong&gt;&lt;em&gt;=&lt;/em&gt;&lt;/strong&gt;赋值操作符&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>esp8266开发</title>
      <link>https://bg2bkk.github.io/post/esp8266%E5%BC%80%E5%8F%91/</link>
      <pubDate>Mon, 22 Aug 2016 16:25:34 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/esp8266%E5%BC%80%E5%8F%91/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://suda-morris.github.io/blog/2015/12/06/esp8266/&#34;&gt;http://suda-morris.github.io/blog/2015/12/06/esp8266/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>shutdown_vs_close_in_tcp</title>
      <link>https://bg2bkk.github.io/post/shutdown_vs_close_in_tcp/</link>
      <pubDate>Thu, 18 Aug 2016 19:40:53 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/shutdown_vs_close_in_tcp/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/jnu_simba/article/details/9068059&#34;&gt;http://blog.csdn.net/jnu_simba/article/details/9068059&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>redis client buffer</title>
      <link>https://bg2bkk.github.io/post/redis_client_buffer/</link>
      <pubDate>Thu, 18 Aug 2016 11:51:16 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/redis_client_buffer/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://zhuoroger.github.io/2016/07/30/redis-client-two-buffers/&#34;&gt;redis客户端的两个buffer&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;query buffer

&lt;ul&gt;
&lt;li&gt;相当于redis为客户提供的输入buffer，不论用户执行get，还是set，都会将命令和参数写到该buffer&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;output buffer

&lt;ul&gt;
&lt;li&gt;相当于redis为客户提供的输出buffer，所以对客户的输出，不论大还是小，都会写到该buffer然后输出&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查询redis client属性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;redis命令：client list&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;10.13.112.54:6379&amp;gt; client list
id=222464 addr=10.13.112.54:46957 fd=8 name= age=46008 idle=1 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=expire
id=222543 addr=10.13.112.54:34158 fd=7 name= age=41737 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=select
id=223496 addr=10.13.112.54:36934 fd=10 name= age=593 idle=2 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=expire
id=223514 addr=10.75.12.239:60522 fd=26 name= age=32 idle=32 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=hincrby
id=223505 addr=10.13.112.54:43949 fd=16 name= age=64 idle=64 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=hincrby
id=223506 addr=10.13.112.54:44754 fd=17 name= age=61 idle=61 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=select
id=223519 addr=172.16.193.186:32256 fd=31 name= age=22 idle=22 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=hincrby
id=223504 addr=172.16.193.186:40687 fd=15 name= age=68 idle=33 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=hincrby
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;qbuf: query buffer 大小&lt;/li&gt;

&lt;li&gt;&lt;p&gt;qbuf-free: query free buffer 大小&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;obl: 定长 output buffer的使用字节数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;oll: 可变 output buffer的对象个数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;omem: 可变 output buffer的使用字节数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;query-buffer:088024c5ecb992faa3cbd591778d5d78&#34;&gt;query buffer&lt;/h2&gt;

&lt;p&gt;redis动态调整每个客户端的query buffer大小，范围0~1GB之间，当某个客户端query buffer使用超过1GB，redis会立刻关闭它，以防OOM&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;query buffer的大小限制是硬编码的：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;server.h#163
/* Protocol and I/O related defines */
#define PROTO_MAX_QUERYBUF_LEN  (1024*1024*1024) /* 1GB max query buffer. */
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;query buffer大小不受maxmemory限制

&lt;ul&gt;
&lt;li&gt;文章中作者模拟100个客户端，连续写入500MB的Key，此时内存占用43GB，而maxmemory限制为4GB，因此这相当于是一个bug。&lt;/li&gt;
&lt;li&gt;虽然maxmemory不能限制该buffer，但是该buffer大小却会计入maxmemory，此时会触发redis的LRU淘汰机制，或者无法写入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;output-buffer:088024c5ecb992faa3cbd591778d5d78&#34;&gt;output buffer&lt;/h2&gt;

&lt;p&gt;客户端output buffer有两种：静态大小buffer和动态buffer&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;静态大小buffer

&lt;ul&gt;
&lt;li&gt;定长16KB，用于存储返回小结果&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;动态大小buffer

&lt;ul&gt;
&lt;li&gt;存储大的结果&lt;/li&gt;
&lt;li&gt;redis提供配置动态output buffer的指令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;client-output-buffer-limit normal 10mb 5mb 60	配置普通客户端的output buffer大小，硬限制是10mb，软限制为5mb/持续60s
client-output-buffer-limit slave 256mb 64mb 60	配置redis从机的output buffer大小，硬限制是256mb，软限制为64mb/持续60s
client-output-buffer-limit pubsub 32mb 8mb 60	配置pub/sub客户端的output buffer大小，硬限制是32mb，软限制为8mb/持续60s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;client-output-buffer-limit的解读是，如果buffer大小超过硬限制，redis立刻断开客户端；如果buffer大小超过软限制，并且持续时长超过60s，则redis断开客户端连接&lt;/p&gt;

&lt;p&gt;如果硬限制和软限制设置为0，则redis将不会主动断开，显然这是不安全的&lt;/p&gt;

&lt;p&gt;redis主动断开的设置，在设置timeout时，如果设置为0，也不会主动断开客户，而是等待客户主动断开&lt;/p&gt;

&lt;p&gt;由于每个客户端都会有大小不等的output buffer，所以当客户端总量很大时，占用内存也是非常客观的；因此开发时客户端应该节省使用redis，尽量使用小一点的key；限制slave的buffer大小，避免返回被杀；还有就是，如果监控redis发现 used memory 抖动严重，那么极有可能是client的大量来袭或者请求访问的动态变化导致。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>三斗大神在es上的三个问题</title>
      <link>https://bg2bkk.github.io/post/%E4%B8%89%E6%96%97%E5%A4%A7%E7%A5%9E%E5%9C%A8es%E4%B8%8A%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 17 Aug 2016 20:00:25 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/%E4%B8%89%E6%96%97%E5%A4%A7%E7%A5%9E%E5%9C%A8es%E4%B8%8A%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;饶琛琳(251562081)  19:53:00
哈哈。一个是es打开lucene索引的内存消耗较大，所以无法保存较长时间索引。现在是close掉，但是close状态的如果宕机是不会自动恢复的，如果连着挂就彻底废了。所以修改方向是钻研lucene源码，用很小的内存维护索引的打开状态，不用的信息只在真正查询到的时候才动态加载
饶琛琳(251562081)  19:54:52
另一个方向是利用snapshot API导出索引到HDFS上，但是不用restore回来查，而是针对es的snapshot格式开发一个hadoop的inputformat，可以直接在hdfs上查询
饶琛琳(251562081)  19:57:18
第三个是es目前各线程是抢cpu的，如果搜一个特别大的范围的结果，可能这一个请求就hang住整个集群其他所有任务，读写都死了，甚至节点掉线啥的。修改方向两种：利用cgroup机制限制每个search thread的资源占用；或者自动切分大请求成多个小请求。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>raspberry安装ffmpeg</title>
      <link>https://bg2bkk.github.io/post/raspberry%E5%AE%89%E8%A3%85ffmpeg/</link>
      <pubDate>Mon, 15 Aug 2016 08:00:14 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/raspberry%E5%AE%89%E8%A3%85ffmpeg/</guid>
      <description>&lt;p&gt;ffmpeg和opencv是我的老朋友了，读研的时候犯轴，非要自己编译，每次编译好几个小时，在arm板子上。其实我需要的就是个库，先把应用写好，优化的事情可以以后再说，优先级不能变。因此现在我做应用，怎么省事怎么来，这是资源和时间的合理配置。能docker就都docker了，不能的话也要找apt-get，总之时间不能花费在编译这些库上，今天编译，下次还编译，这是很什么效率？&lt;/p&gt;

&lt;p&gt;树莓派是有opencv的apt-get软件包的，所以可以直接安装；ffmpeg麻烦点，不过也找到&lt;a href=&#34;https://github.com/ccrisan/motioneye/wiki/Install-On-Raspbian&#34;&gt;有人打包好的&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pcworld.com/article/2598363/how-to-set-up-raspberry-pi-the-little-computer-you-can-cook-into-diy-tech-projects.html&#34;&gt;树莓派model 1B+上手&lt;/a&gt;，model 1B+是高于model 1低于model 2的奇葩版本，希望广大网民不要像我这样，买个奇葩的板子哈哈&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ubuntu-pi-flavour-maker.org/download/&#34;&gt;https://ubuntu-pi-flavour-maker.org/download/&lt;/a&gt;
&lt;a href=&#34;https://wiki.ubuntu.com/ARM/RaspberryPi&#34;&gt;https://wiki.ubuntu.com/ARM/RaspberryPi&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker操作指南</title>
      <link>https://bg2bkk.github.io/post/docker%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sun, 14 Aug 2016 16:09:53 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/docker%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;p&gt;docker学习操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;docker info

&lt;ul&gt;
&lt;li&gt;查看docker是否正常工作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;systemctl status docker&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查看docker守护进程是否工作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;docker ps&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查看正在运行的容器&lt;/li&gt;
&lt;li&gt;docker ps -a 查看所有容器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;docker images&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查看镜像&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;docker run -t -i ubuntu /bin/bash&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;运行docker镜像&lt;/li&gt;
&lt;li&gt;-t 开启terminal&lt;/li&gt;
&lt;li&gt;-i 保证stdin开启&lt;/li&gt;
&lt;li&gt;docker run &amp;ndash;name huang_ubuntu -t -i ubuntu /bin/bash

&lt;ul&gt;
&lt;li&gt;别名huang_ubuntu&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;docker attach huang_ubuntu&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;重新附着到运行容器中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行守护式容器&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;docker run &amp;ndash;name daemon_ubuntu -d ubuntu /bin/bash -c $CMD&lt;/li&gt;
&lt;li&gt;docker logs -f daemon_ubuntu

&lt;ul&gt;
&lt;li&gt;查看docker日志&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;docker logs -ft daemon_ubuntu

&lt;ul&gt;
&lt;li&gt;加上时间戳&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;docker stats huang_ubuntu&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;容器运行信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;docker exec -t -i huang_ubuntu /bin/bash&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;docker容器中执行程序，采用-t -i方式打开/bin/bash可以打开容器终端，能够附着在运行中容器里&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://docs.daocloud.io/allen-docker/docker-build-cache&#34;&gt;docker build&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.heblug.org/chinese_docker/examples/mongodb.html&#34;&gt;mongoDB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>docker学习之路</title>
      <link>https://bg2bkk.github.io/post/docker%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</link>
      <pubDate>Fri, 12 Aug 2016 00:26:03 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/docker%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</guid>
      <description></description>
    </item>
    
    <item>
      <title>nginx接收用户请求的过程</title>
      <link>https://bg2bkk.github.io/post/nginx%E6%8E%A5%E6%94%B6%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Thu, 11 Aug 2016 18:07:19 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/nginx%E6%8E%A5%E6%94%B6%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.voidcn.com/blog/fengmo_q/article/p-2425250.html&#34;&gt;nginx从启动worker到处理一个用户请求&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1、nginx启动时，在init_process阶段首先注册事件和处理方法。首先为每个listen fd分配一个ngx_connection_t，并为它设置读时间处理函数，ngx_event_accept&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果nginx没有开启accept_mutex，则直接将ngx_event_accept挂载nginx的事件处理模型epoll上&lt;/li&gt;
&lt;li&gt;否则等到init_process阶段结束，在worker的事件处理循环中竞争到锁之后才挂载用于接收新请求的读事件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2、当worker监听到读事件，nginx就可以接收客户端的请求；用户向nginx发起请求后，nginx的事件处理模型收到读事件，然后调用ngx_event_accept处理&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ngx_event_accept中，nginx调用accept，从TCP协议栈的已连接队列中取到一个连接和对应的socket，接着分配一个ngx_connection_t，将其与该socket对应&lt;/li&gt;
&lt;li&gt;接着初始化该连接：

&lt;ul&gt;
&lt;li&gt;src/event/ngx_event_accept.c&lt;/li&gt;
&lt;li&gt;为该连接分配一个256B大小的内存池&lt;/li&gt;
&lt;li&gt;初始化读写事件对应的处理和回调函数handler: c-&amp;gt;rev = ngx_recv等&lt;/li&gt;
&lt;li&gt;分配log结构，以便后续log系统使用&lt;/li&gt;
&lt;li&gt;分配一个套接口地址sockaddr，将对端tcp地址保存在其中&lt;/li&gt;
&lt;li&gt;将本地套接口地址保存在local_sockaddr中；因为有时候从监听结构ngx_listenging_t中获得的监听地址可能是通配符*******，而本地套接地址是真实地址&lt;/li&gt;
&lt;li&gt;设置ready为1，即设置该连接的写事件就绪&lt;/li&gt;
&lt;li&gt;如果socket设置了TCP_DEFER_ACCEPT属性，则表示该连接上已经有数据包了，于是设置事件为读就绪&lt;/li&gt;
&lt;li&gt;将sockaddr保存的对端地址格式化为可读字符串&lt;/li&gt;
&lt;li&gt;最后调用ngx_http_init_connection初始化该连接的其他部分&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;       TCP_DEFER_ACCEPT (since Linux 2.4)
              Allow a listener to be awakened only when data arrives on the
              socket.  Takes an integer value (seconds), this can bound the
              maximum number of attempts TCP will make to complete the
              connection.  This option should not be used in code intended
              to be portable.

		允许只有当监听事件者只有当有数据时才被唤醒；参数是整数，可以限制一个TCP为了处理完成一个连接所做的最多尝试次数
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    * ngx_http_init_connection
        * 初始化读写事件处理函数
            * 写事件：ngx_http_empty_handler
            * 读事件：ngx_http_init_request
                * 如果连接上有数据过来，则调用该函数处理数据
                * 否则设置定时器，等待数据到来或者超时，再在该函数中处理
* 初始化用户请求：ngx_http_init_request
    * 它是一个事件处理函数，唯一的参数是ngx_event_t *；
    * 进入该事件处理函数后，判断是否超时，如果超时，则直接关闭连接并返回；否则继续
    * 在连接的内存池中分配一个ngx_http_request_t结构，用于保存请求的所有信息，并设置为该连接的request字段
    * nginx根据该请求的端口和地址，找到一个默认vhost(第一个定义的server)，或者根据域名来区分监听相同端口和地址的vhost，临时使用，最终找到真正的目标vhost；
    * 进入vhost后，将连接的读事件处理函数ngx_http_process_request_line函数，解析请求行；为这个请求分配缓冲区，保存header头在request-&amp;gt;header_in，默认1024B，在该请求所在连接的内存池中分配
    * 将请求的引用计数count字段设置为1；将当前时间设置为start_sec和start_mset；nginx以接收到客户端的第一个数据包的时间作为起始，apache则以接收到整个request line开始
    * 初始化请求的其他字段，比如将uri_changes设置为11，表示最多可以将该请求的uri改写10次，subrequests被设置为201，表示一个请求最多可以发起200个子请求； 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>nginx模块开发那些事</title>
      <link>https://bg2bkk.github.io/post/nginx%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
      <pubDate>Thu, 11 Aug 2016 17:44:27 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/nginx%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://yanyiwu.com/work/2014/09/21/nginx-module-development-stuff.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;nginx为每个连接分配内存池&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;r-&amp;gt;pool是r的连接池，所有内存操作都在这里完成；请求结束后，该pool将会释放，因此没有内存泄露问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nginx的异步通信&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;回调函数是nginx实现异步操作的方式&lt;/li&gt;
&lt;li&gt;以ngx读取POST请求的request body为例，每次epoll监听到socket有数据进来的时候，就非阻塞的调用recv接收数据并累计，直到数据大于等于Header头部中的&amp;rdquo;Content-Length&amp;rdquo;(HTTP请求的Header部分此时已经被处理)，然后调用模块的回调函数对所有POST数据进行处理。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nginx的sendfile、TCP_NODELAY和TCP_NOPUSH&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;互联网早期，由于网络链路质量不好，在发送数据时，如果只是很小的数据包，TCP/IP协议栈将会等待200ms，收集更多数据包后一次发出，可以提高吞吐量，这个算法成为Nagle算法；随着通信技术进步，Nagle算法逐渐不合实际，在nginx中甚至需要TCP_NODELAY来禁用socket的Nagle算法，要求有数据包后立刻发出&lt;/li&gt;
&lt;li&gt;TCP_NOPUSH显然是与TCP_NODELAY相冲突的，那为什么它存在呢？&lt;/li&gt;
&lt;li&gt;对于sendfile on这一配置而言，由于系统调用sendfile有着“零拷贝”的优势，在内核中从in_fd复制到out_fd，不足之处是in_fd只能是文件fd，因此sendfile只能用于发送文件到网络IO；当TCP_NOPUSH、TCP_NODELAY和sendfile配合起来，就很有意思了：在调用sendfile之前，将out_fd这一socket设置为TCP_NOPUSH的，sendfile将文件数据写到socket缓冲区，在sendfile完成后，去掉out_fd的TCP_NOPUSH选项，将文件数据一次发出，可以提高性能。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nginx的sendfile，还有读取用户请求的post数据等，灵活的操作内存缓冲区，代码质量很高，值得品味&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://t37.net/nginx-optimization-understanding-sendfile-tcp_nodelay-and-tcp_nopush.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sendfile, tcp_nodelay和tcp_nopush是怎样对nginx产生影响的呢？

&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>nodejs拾疑</title>
      <link>https://bg2bkk.github.io/post/nodejs%E6%8B%BE%E7%96%91/</link>
      <pubDate>Wed, 10 Aug 2016 20:58:28 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/nodejs%E6%8B%BE%E7%96%91/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://yjhjstz.gitbooks.io/deep-into-node/content/chapter7/chapter7-1.html&#34;&gt;https://yjhjstz.gitbooks.io/deep-into-node/content/chapter7/chapter7-1.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>skiplist</title>
      <link>https://bg2bkk.github.io/post/skiplist/</link>
      <pubDate>Wed, 10 Aug 2016 20:44:15 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/skiplist/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/flyfy1/archive/2011/02/24/1963347.html&#34;&gt;http://www.cnblogs.com/flyfy1/archive/2011/02/24/1963347.html&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/zy825316/article/details/22600003&#34;&gt;http://blog.csdn.net/zy825316/article/details/22600003&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/ict2014/article/details/17394259&#34;&gt;http://blog.csdn.net/ict2014/article/details/17394259&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.leoox.com/?p=347&#34;&gt;http://www.leoox.com/?p=347&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html&#34;&gt;http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html&#34;&gt;http://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>redis源码阅读</title>
      <link>https://bg2bkk.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
      <pubDate>Wed, 10 Aug 2016 15:10:37 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid>
      <description>

&lt;h2 id=&#34;有序集:4a3b87845c2742981345b5d7ae1349ee&#34;&gt;有序集&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://redisbook.readthedocs.io/en/latest/datatype/sorted_set.html#sorted-set-chapter&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编码方式

&lt;ul&gt;
&lt;li&gt;ziplist 编码方式&lt;/li&gt;
&lt;li&gt;skiplist 编码方式&lt;/li&gt;
&lt;li&gt;在redis配置文件中，有如下配置

&lt;ul&gt;
&lt;li&gt;zset-max-ziplist-entries和zset-max-ziplist-value不满足其中之一的时候，采用ziplist编码&lt;/li&gt;
&lt;li&gt;否则采用skiplist方式编码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Similarly to hashes and lists, sorted sets are also specially encoded in
# order to save a lot of space. This encoding is only used when the length and
# elements of a sorted set are below the following limits:
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ziplist编码方式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ziplist将节点KV按顺序压缩排序在一块内存，类型为ZIPLIST，查找特定元素时按序查找，时间复杂度为O(N)，增删查等更新操作的时间复杂度都会大于O(N)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;skiplist编码方式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;采用skiplist编码方式时，zset定义如下：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
 * 有序集
 */
typedef struct zset {

    // 字典
    dict *dict;

    // 跳跃表
    zskiplist *zsl;

} zset;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;* zset采用跳表和哈希表共同维护，通过将skiplist和hash set的指针指向同一对象来共享数据
    * 查找时，从hash set中以O(1)的时间复杂度读取数据
    * 查找区间时，从skip list中以O(N)的复杂度获取区间
    * 通过score对key进行定位时，skip list可以以最坏O(N)，期望O(log N)的时间复杂实现
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>redis过期清除机制及应用方法</title>
      <link>https://bg2bkk.github.io/post/redis%E8%BF%87%E6%9C%9F%E6%B8%85%E9%99%A4%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BA%94%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Aug 2016 13:26:07 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/redis%E8%BF%87%E6%9C%9F%E6%B8%85%E9%99%A4%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BA%94%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>

&lt;h2 id=&#34;redis过期清除和淘汰机制:15f341755a194cb3fa2a102ac1aec971&#34;&gt;redis过期清除和淘汰机制&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;过期时间设置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;expire key seconds&lt;/li&gt;
&lt;li&gt;该命令设置指定key超时的秒数，超过该时间后，可以将被删除&lt;/li&gt;
&lt;li&gt;在超时之前，如果该key被修改，与之关联的超时将被移除

&lt;ul&gt;
&lt;li&gt;persist key 持久化该key，超时时间移除&lt;/li&gt;
&lt;li&gt;set key newvalue 设置新值，会清除过期时间&lt;/li&gt;
&lt;li&gt;del key   显然会清除过期时间&lt;/li&gt;
&lt;li&gt;例外情况：

&lt;ul&gt;
&lt;li&gt;lpush, zset, incr等操作，在高版本（2.1.3++）之后不会清除过期时间，毕竟修改的不是key本身&lt;/li&gt;
&lt;li&gt;rename 也不会清除过期时间，只是改key名字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;过期处理&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;redis对过期key采用lazy expiration方式，在访问key的时候才判定该key是否过期&lt;/li&gt;
&lt;li&gt;此外，每秒还会抽取volatile keys进行抽样，处理删除过期键&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.marser.cn/archives/87/&#34;&gt;过期键删除策略种类&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事件删除

&lt;ul&gt;
&lt;li&gt;每个键都有一个定时器，到期时触发处理事件，在事件中删除&lt;/li&gt;
&lt;li&gt;缺点是需要为每个key维护定时器，key的量大时，cpu消耗较大&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;惰性删除

&lt;ul&gt;
&lt;li&gt;每次访问时才检查，如果没过期，正常返回，否则删除该键并返回空&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定期删除&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每隔一段时间，检查所有设置了过期时间的key，删除已过期的键&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;redis采用后两种结合的方式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读写一个key时，触发惰性删除策略&lt;/li&gt;
&lt;li&gt;惰性删除策略不能及时处理冷数据，因此redis会定期主动淘汰一批已过期的key&lt;/li&gt;
&lt;li&gt;内存超过maxmemory时，触发主动清理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blueswind8306.iteye.com/blog/2240088&#34;&gt;http://blueswind8306.iteye.com/blog/2240088&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/chenpingzhao/p/5022467.html&#34;&gt;http://www.cnblogs.com/chenpingzhao/p/5022467.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>effective tips in daily work</title>
      <link>https://bg2bkk.github.io/post/effective%20tips%20in%20daily%20work/</link>
      <pubDate>Sun, 24 Jul 2016 16:36:33 +0800</pubDate>
      
      <guid>https://bg2bkk.github.io/post/effective%20tips%20in%20daily%20work/</guid>
      <description>

&lt;h2 id=&#34;epoll是同步非阻塞的:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;epoll是同步非阻塞的&lt;/h2&gt;

&lt;p&gt;epoll、select等多路服用IO，将fd加入等待时间的队列中，每隔一段时间去轮询一次，因此是同步的；优点是能够在等待任务的时间里去做别的任务；缺点是任务完成的响应延迟增大，因为每隔一段时间去轮询他们，在时间间隔内任务可能已经完成而等待处理等待了一段时间了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ring0.me/2014/11/sync-async-blocked/&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;同步/异步指的是被调用方的通知方式，被调用方完成后，主动通知调用方，还是等待调用方发现。前者是异步，后者是同步。从这里也可以看出，&lt;a href=&#34;https://segmentfault.com/a/1190000003063859&#34;&gt;异步IO通知调用方时，数据已经就绪&lt;/a&gt;，对于网络IO来说，异步IO已经将数据从内核复制到用户空间了。&lt;/p&gt;

&lt;p&gt;阻塞/非阻塞是调用方的等待方式，是一直等待在做的事件完成，还是去做别的事情，等到在做的事件完成后再接着进行处理。前者是阻塞，后者是非阻塞&lt;/p&gt;

&lt;p&gt;因此epoll是同步和非阻塞的。&lt;/p&gt;

&lt;h2 id=&#34;sed合并相邻两行:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;sed合并相邻两行&lt;/h2&gt;

&lt;p&gt;从redis中取出一个键的所有内容时，比如hgetall，得到的结果并不是排序好的，类似于这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;11485) &amp;quot;1470347460&amp;quot;
11486) &amp;quot;69&amp;quot;
11487) &amp;quot;1470262350&amp;quot;
11488) &amp;quot;34&amp;quot;
11489) &amp;quot;1470262170&amp;quot;
11490) &amp;quot;68&amp;quot;
11491) &amp;quot;1470242400&amp;quot;
11492) &amp;quot;21&amp;quot;
11493) &amp;quot;1470288030&amp;quot;
11494) &amp;quot;65&amp;quot;
11495) &amp;quot;1470303390&amp;quot;
11496) &amp;quot;54&amp;quot;
11497) &amp;quot;1470205320&amp;quot;
11498) &amp;quot;85&amp;quot;
11499) &amp;quot;1470318330&amp;quot;
11500) &amp;quot;92&amp;quot;
11501) &amp;quot;1470167040&amp;quot;
11502) &amp;quot;1&amp;quot;
11503) &amp;quot;1470281880&amp;quot;
11504) &amp;quot;14&amp;quot;
11505) &amp;quot;1470298140&amp;quot;
11506) &amp;quot;113&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该hash的key为unix时间戳，val为数值，如果想手动看分布的话，需要将相邻两行合并然后排序，在此我们&lt;a href=&#34;http://blog.chinaunix.net/uid-9950859-id-98222.html&#34;&gt;借助sed&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sed &#39;$!N;s/\n/\t/&#39; filename 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;redis分析实例中所有key和单个key的内存占用情况:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;redis分析实例中所有key和单个key的内存占用情况&lt;/h2&gt;

&lt;p&gt;采用&lt;a href=&#34;https://github.com/sripathikrishnan/redis-rdb-tools&#34;&gt;rdb工具&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rdb -c memory /path/to/ab-dump.rdb &amp;gt; memory.csv
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sort进行多重排序:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;sort进行多重排序&lt;/h2&gt;

&lt;p&gt;sort和uniq在文本处理，尤其是日志处理中用的较多的工具，记得当年校招时候准备面试，用到这两个命令，惊为天人，非常shock。在日常工作中，用的也非常多。&lt;/p&gt;

&lt;p&gt;目前有这样的需求，拿到两列数据，第一列是ip，第二列是访问计数，想看一下分布，要求ip要按文本排序，访问计数按数值排序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;221.179.175.109	97
221.179.175.164	101
221.179.175.46	8
221.179.175.164	102
221.179.175.178	78
221.179.175.46	9
221.179.175.109	98
221.179.175.178	79
120.239.141.197	96
221.179.175.70	114
218.202.7.121	70
221.179.175.178	80
218.202.7.121	71
221.179.175.134	83
120.239.141.197	97
221.179.175.46	10
221.179.175.178	81
221.179.175.47	24
120.239.141.197	98
221.179.175.70	115
221.179.175.70	116
120.239.141.197	99
221.179.175.134	84

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.chinaunix.net/uid-25504049-id-3075909.html&#34;&gt;解决方法&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sort -t &#39; &#39; -k1,1 -k2n,2 data


其中 -t &#39; &#39; 指定使用空格分列
-k1,1  指定以第一列为关键字排序
-k2n,2 指定以第二列为关键字做数据排序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/dabingxiaozu/article/details/6213851&#34;&gt;也可以&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sort -k1 -k2n out
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;shell脚本批量处理文本:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;shell脚本批量处理文本&lt;/h2&gt;

&lt;p&gt;善用awk、grep、xargs、bash、sed等工具，可以提高生产力&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep &#39;config.config&#39; . -r | awk -F&#39;:&#39; &#39;{print $1}&#39; | grep &#39;lua$&#39; | xargs sed &amp;quot;s/config.config&#39;)/config.config&#39;).ab/g&amp;quot; -i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;shell循环&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for j in {a..z}; do echo $j; done
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;redis批量删除key:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;redis批量删除key&lt;/h2&gt;

&lt;p&gt;手动清理redis中的key时，很想通过 &lt;strong&gt;&lt;em&gt;del keys&lt;/em&gt;&lt;/strong&gt;* 的方式实现批量删除，而redis却没有提供这样的选项，因此需要借助外部工具&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、sehll 命令行&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;redis-cli keys ip:* | xargs redis-cli del&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2、lua脚本&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;redis-cli eval &amp;ldquo;redis.call(&amp;lsquo;del&amp;rsquo;, unpack(redis.call(&amp;lsquo;keys&amp;rsquo;,&amp;lsquo;ip*&amp;lsquo;)))&amp;rdquo; 0&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;这种方式受限于lua的unpack函数，一次删除的key不能太多&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3、借助客户端&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.redisfans.com/?p=71&#34;&gt;php&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/tuposky/article/details/45364107&#34;&gt;jedis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;unix获取时间戳:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;unix获取时间戳&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;date &#39;+%s&#39;

export timestamp=`date &#39;+%s&#39;`; echo $timestamp

# 标准时间格式转unix时间戳
date -d &amp;quot;2011-03-02 15:00&amp;quot; +%s

# unix时间戳转为标准格式
date -d &#39;1970-01-01 UTC 1299049200 seconds&#39;

# 或者

date -d &amp;quot;@1279592730&amp;quot; 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/hittata/article/details/7640974&#34;&gt;链接&lt;/a&gt;中提到了各种各样的格式，以后写shell脚本就不担心时间戳问题了&lt;/p&gt;

&lt;h2 id=&#34;docker-设置代理下载镜像:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;docker 设置代理下载镜像&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/23111631/cannot-download-docker-images-behind-a-proxy&#34;&gt;在systemd中设置&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;mkdir /etc/systemd/system/docker.service.d&lt;p&gt;&lt;/li&gt;
&lt;li&gt;touch /etc/systemd/system/docker.service.d/http-proxy.conf&lt;p&gt;&lt;/li&gt;
&lt;li&gt;在文件中添加：&lt;p&gt;[Service]&lt;p&gt;Environment=&amp;ldquo;HTTP_PROXY=&lt;a href=&#34;http://proxy.example.com:80/&amp;quot;&#34;&gt;http://proxy.example.com:80/&amp;quot;&lt;/a&gt;&lt;p&gt;&lt;/li&gt;
&lt;li&gt;重启daemon：&lt;p&gt;sudo systemctl daemon-reload&lt;p&gt;&lt;/li&gt;
&lt;li&gt;查看设置状态：&lt;p&gt;sudo systemctl show docker &amp;ndash;property Environment&lt;p&gt;&lt;/li&gt;
&lt;li&gt;重启docker：&lt;p&gt;sudo systemctl restart docker&lt;p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;tested on Ubuntu 16.04&lt;/p&gt;

&lt;h2 id=&#34;用ps查看进程的执行时间:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;用ps查看进程的执行时间&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ps -eo pid,tty,user,comm,stime,etime | grep main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以打印进程的开始时间和执行时间&lt;/p&gt;

&lt;h2 id=&#34;vim下以16进制查看文本文件:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;vim下以16进制查看文本文件&lt;/h2&gt;

&lt;p&gt;vim的功能实在是太强大了，&lt;a href=&#34;http://blog.sina.com.cn/s/blog_4c451e0e0100h4nl.html&#34;&gt;可以以16进制查看文本信息&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;十六进制显示
:%!xxd
正常显示
:%!xxd -r
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;linux获取系统调度时间片长度:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;Linux获取系统调度时间片长度&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define _GNU_SOURCE
#include &amp;lt;sched.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;

	int
main(int argc, char *argv[])
{
	int ret, i;  
	struct timespec tp;  
	ret = sched_rr_get_interval(0, &amp;amp;tp);  
	if(ret == -1)  
		printf(&amp;quot;sched_rr_get_interval error.\n&amp;quot;);  
	printf(&amp;quot;The time is %ds:%ldns.\n&amp;quot;, (int)tp.tv_sec, tp.tv_nsec);  
	return 0;  
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./cpu_time_slice.o 
The time is 0s:16000000ns.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见Ubuntu-16.04 64bit的系统进程时间片是16ms&lt;/p&gt;

&lt;h2 id=&#34;c语言中short-int-long内存占用:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;C语言中short、int、long内存占用&lt;/h2&gt;

&lt;p&gt;随着工作年限的增加，很多基本功反而落了下来，甚至开始怀疑short等类型的内存占用问题了呵呵。印象里一直记得int和long类型都是4字节大小啊&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

struct test{
	char *ch1;
	int i;
	long ch2;
} aa;

int main()
{
	printf(&amp;quot;Linux-64Bit-platform\n&amp;quot;);
	printf(&amp;quot;	%lu\n&amp;quot;, (unsigned long)sizeof(aa));
	printf(&amp;quot;	sizeof short : %d\n&amp;quot;, sizeof(short));
	printf(&amp;quot;	sizeof int   : %d\n&amp;quot;, sizeof(int));
	printf(&amp;quot;	sizeof long  : %d\n&amp;quot;, sizeof(long));
	
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Linux-64Bit-platform
	24
	sizeof short : 2
	sizeof int   : 4
	sizeof long  : 8

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Linux-32Bit-platform
	24
	sizeof short : 2
	sizeof int   : 4
	sizeof long  : 4

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看来，long和int大小一样已经是32位机器的老黄历了，基础知识还是应该常用常新啊&lt;/p&gt;

&lt;h2 id=&#34;文件操作的线程安全相关-待续:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;文件操作的线程安全相关（待续）&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/29981050/concurrent-writing-to-a-file&#34;&gt;http://stackoverflow.com/questions/29981050/concurrent-writing-to-a-file&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ubuntu关闭键盘和触摸板的方法:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu关闭键盘和触摸板的方法&lt;/h2&gt;

&lt;p&gt;家里的猫就是喜欢趴在笔记本键盘上看你干活，我只能再买一个键盘，然后笔记本键盘留给猫大爷了。&lt;/p&gt;

&lt;p&gt;然而它还喜欢在键盘上跳舞，这样太影响输入了，只能想办法把笔记本键盘关掉。&lt;/p&gt;

&lt;p&gt;在ubuntu下，键盘鼠标触控板都属于xinput设备，可以通过以下命令查看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
$ xinput  --list
⎡ Virtual core pointer                    	id=2	[master pointer  (3)]
⎜   ↳ Virtual core XTEST pointer              	id=4	[slave  pointer  (2)]
⎜   ↳ SynPS/2 Synaptics TouchPad              	id=16	[slave  pointer  (2)]
⎜   ↳ Rapoo Rapoo Gaming Keyboard             	id=11	[slave  pointer  (2)]
⎜   ↳ RAPOO Rapoo 2.4G Wireless Device        	id=12	[slave  pointer  (2)]
⎜   ↳ Wacom ISDv4 E6 Pen stylus               	id=13	[slave  pointer  (2)]
⎜   ↳ Wacom ISDv4 E6 Finger touch             	id=14	[slave  pointer  (2)]
⎜   ↳ Wacom ISDv4 E6 Pen eraser               	id=18	[slave  pointer  (2)]
⎜   ↳ TPPS/2 IBM TrackPoint                   	id=19	[slave  pointer  (2)]
⎣ Virtual core keyboard                   	id=3	[master keyboard (2)]
    ↳ Virtual core XTEST keyboard             	id=5	[slave  keyboard (3)]
    ↳ Power Button                            	id=6	[slave  keyboard (3)]
    ↳ Video Bus                               	id=7	[slave  keyboard (3)]
    ↳ Sleep Button                            	id=8	[slave  keyboard (3)]
    ↳ Integrated Camera                       	id=9	[slave  keyboard (3)]
    ↳ Rapoo Rapoo Gaming Keyboard             	id=10	[slave  keyboard (3)]
    ↳ AT Translated Set 2 keyboard            	id=15	[slave  keyboard (3)]
    ↳ ThinkPad Extra Buttons                  	id=17	[slave  keyboard (3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到笔记本键盘是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    ↳ AT Translated Set 2 keyboard            	id=15	[slave  keyboard (3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而触控板是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;⎜   ↳ SynPS/2 Synaptics TouchPad              	id=16	[slave  pointer  (2)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他们的id分别是 15和 16，所以采用以下命令关掉就可以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo sudo xinput set-prop 15 &amp;quot;Device Enabled&amp;quot; 0
sudo sudo xinput set-prop 16 &amp;quot;Device Enabled&amp;quot; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;附送shell脚本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

keyboard=`xinput --list | grep AT | awk -F&#39;=&#39; &#39;{print $2}&#39; | awk &#39;{print $1}&#39;`
touchpad=`xinput --list | grep Synaptics | awk -F&#39;=&#39; &#39;{print $2}&#39; | awk &#39;{print $1}&#39;`

function doit() {
	echo &#39;关闭  笔记本键盘&#39;
	`sudo xinput set-prop $keyboard &amp;quot;Device Enabled&amp;quot; 0`			
	echo &#39;关闭  笔记本触摸板&#39;
	`sudo xinput set-prop $touchpad &amp;quot;Device Enabled&amp;quot; 0`
}

doit 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;小于1024的保留端口都有哪些:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;小于1024的保留端口都有哪些&lt;/h2&gt;

&lt;p&gt;我们会遇到如下情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo tcpdump -i any port 1080
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes
15:08:42.421693 IP localhost.55092 &amp;gt; localhost.socks: Flags [.], ack 1960200857, win 342, options [nop,nop,TS val 4687328 ecr 4676064], length 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我想监听1080端口，tcpdump为什么不乖乖显示1080，而是出现个socks呢？（可以通过&lt;strong&gt;&lt;em&gt;-n&lt;/em&gt;&lt;/strong&gt;参数解决）为什么1080是socks，而不是别的呢？&lt;/p&gt;

&lt;p&gt;这是因为低于1024的保留端口大多有自己的名字，他们&lt;a href=&#34;http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml&#34;&gt;由IANA分配&lt;/a&gt;，通常用于系统进程，而我们可以在&lt;strong&gt;&lt;em&gt;/etc/services&lt;/em&gt;&lt;/strong&gt;文件中找到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#
# From ``Assigned Numbers&#39;&#39;:
#
#&amp;gt; The Registered Ports are not controlled by the IANA and on most systems
#&amp;gt; can be used by ordinary user processes or programs executed by ordinary
#&amp;gt; users.
#
#&amp;gt; Ports are used in the TCP [45,106] to name the ends of logical
#&amp;gt; connections which carry long term conversations.  For the purpose of
#&amp;gt; providing services to unknown callers, a service contact port is
#&amp;gt; defined.  This list specifies the port used by the server process as its
#&amp;gt; contact port.  While the IANA can not control uses of these ports it
#&amp;gt; does register or list uses of these ports as a convienence to the
#&amp;gt; community.
#
socks		1080/tcp			# socks proxy server
socks		1080/udp
proofd		1093/tcp
proofd		1093/udp
rootd		1094/tcp
rootd		1094/udp
openvpn		1194/tcp
openvpn		1194/udp
rmiregistry	1099/tcp			# Java RMI Registry
rmiregistry	1099/udp
kazaa		1214/tcp
kazaa		1214/udp
nessus		1241/tcp			# Nessus vulnerability
nessus		1241/udp			#  assessment scanner
lotusnote	1352/tcp	lotusnotes	# Lotus Note
lotusnote	1352/udp	lotusnotes
ms-sql-s	1433/tcp			# Microsoft SQL Server
ms-sql-s	1433/udp
ms-sql-m	1434/tcp			# Microsoft SQL Monitor
ms-sql-m	1434/udp
ingreslock	1524/tcp
ingreslock	1524/udp
prospero-np	1525/tcp			# Prospero non-privileged

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git修改默认分支名:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git修改默认分支名&lt;/h2&gt;

&lt;p&gt;在develop分支改动太大了，导致merge 到master分支时非常被动，这个时候我想，干脆将develop分支作为分支好了。还好碰到&lt;a href=&#34;http://stackoverflow.com/questions/1485578/change-a-git-remote-head-to-point-to-something-besides-master&#34;&gt;stackoverflow的一个帖子&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git branch -m master oldmaster&lt;/li&gt;
&lt;li&gt;git branch -m develop master&lt;/li&gt;
&lt;li&gt;git push -f origin master&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另一个方法是从github的&lt;a href=&#34;https://help.github.com/articles/setting-the-default-branch/&#34;&gt;项目主页上更改&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;编译openssl-1-0-2g:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;编译openssl 1.0.2g&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./config shared -fPIC zlib-dynamic &amp;amp;&amp;amp; make depend -j   &amp;amp;&amp;amp; make -j
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编译nginx-tengine-cpp模块:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;编译nginx/tengine: CPP模块&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure --add-module=../cpp_module  --with-ld-opt=&amp;quot;-lstdc++&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;curl-i-和-i的区别:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;curl -i 和 -I的区别&lt;/h2&gt;

&lt;p&gt;man page:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	-i, --include
		(HTTP) Include the HTTP-header in the output. The HTTP-header includes things like server-name, date of the document, HTTP-version and more...
		
	-I, --head
		(HTTP/FTP/FILE) Fetch the HTTP-header only! HTTP-servers feature the command HEAD which this uses to get nothing but the header of a document. When used on an FTP or FILE file, curl displays the file size and last modification time only.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-i选项会打印出HTTP头部的一些信息，这个选项是curl软件的选项，这些信息本来就是存在的&lt;/p&gt;

&lt;p&gt;-I选项会发送HEAD请求，获取信息&lt;/p&gt;

&lt;h2 id=&#34;linux系统如何将父子进程一起kill掉:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;linux系统如何将父子进程一起kill掉&lt;/h2&gt;

&lt;p&gt;对于普通进程而言，kill掉父进程将会连带着把子进程kill掉；而对于daemon等类型进程而言，kill掉父进程，子进程会被daemon接管，所以如果想父子一起kill掉的话，不能直接kill父进程。&lt;/p&gt;

&lt;p&gt;有&lt;a href=&#34;http://blog.csdn.net/lalaguozhe/article/details/11142855&#34;&gt;两种方法&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;kill &amp;ndash; -PPID&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PPID前面有&lt;strong&gt;&lt;em&gt;-&lt;/em&gt;&lt;/strong&gt;号，可以将父子进程kill掉&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用exec或者xargs来kill掉他们&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dns查询中-域名是否可以有多个cname呢:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;dns查询中，域名是否可以有多个cname呢？&lt;/h2&gt;

&lt;p&gt;不可以
    * &lt;a href=&#34;http://serverfault.com/questions/574072/can-we-have-multiple-cnames-for-a-single-name&#34;&gt;http://serverfault.com/questions/574072/can-we-have-multiple-cnames-for-a-single-name&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;git代理访问:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git代理访问&lt;/h2&gt;

&lt;p&gt;git config &amp;ndash;global http.proxy 10.8.0.1:8118&lt;/p&gt;

&lt;h2 id=&#34;ubuntu操作-挂载-格式化sd卡:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu操作、挂载、格式化SD卡&lt;/h2&gt;

&lt;p&gt;玩树莓派等板子的时候，需要从host机器将os镜像烧进sd卡，然后启动。那么ubuntu如何操作呢？&lt;/p&gt;

&lt;p&gt;fdisk -l命令可以用来查看系统中的存储硬件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;

Disk /dev/sda: 111.8 GiB, 120034123776 bytes, 234441648 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: C27256BB-CE04-48C2-96F4-8F79FAE2AE87

Device     Start       End   Sectors   Size Type
/dev/sda1   2048 234440703 234438656 111.8G Linux filesystem


Disk /dev/sdb: 167.7 GiB, 180045766656 bytes, 351651888 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x42b438a2

Device     Boot     Start       End   Sectors  Size Id Type
/dev/sdb1  *         2048 105887743 105885696 50.5G  7 HPFS/NTFS/exFAT
/dev/sdb2       105887744 187807665  81919922 39.1G 83 Linux
/dev/sdb3       187807744 228767743  40960000 19.5G  7 HPFS/NTFS/exFAT
/dev/sdb4       228769790 351649791 122880002 58.6G  f W95 Ext&#39;d (LBA)
/dev/sdb5       228769792 351649791 122880000 58.6G  7 HPFS/NTFS/exFAT


Disk /dev/sdc: 14.9 GiB, 16021192704 bytes, 31291392 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000

Device     Boot Start      End  Sectors  Size Id Type
/dev/sdc1        8192 31291391 31283200 14.9G  c W95 FAT32 (LBA)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果sd卡（tf卡）通过usb 读卡器接入电脑，则会显示为 /dev/sdc&lt;/p&gt;

&lt;p&gt;如果是标准sd卡（大卡），则会显示为 /dev/mmblck0&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Disk /dev/mmcblk0: 14.9 GiB, 16021192704 bytes, 31291392 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00000000

Device         Boot Start      End  Sectors  Size Id Type
/dev/mmcblk0p1       8192 31291391 31283200 14.9G  c W95 FAT32 (LBA)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推荐使用USB读卡器，速度较为快一些。&lt;/p&gt;

&lt;h2 id=&#34;lua库文件的加载路径:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;Lua库文件的加载路径&lt;/h2&gt;

&lt;p&gt;Lua 提供一个名为 &lt;a href=&#34;http://www.lua.org/manual/5.1/manual.html#pdf-require&#34;&gt;require&lt;/a&gt; 的函数来加载模块，使用也很简单，它只有一个参数，这个参数就是要指定加载的模块名，&lt;a href=&#34;http://dhq.me/lua-learning-notes-package-and-module&#34;&gt;例如&lt;/a&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;require(&amp;quot;&amp;lt;模块名&amp;gt;&amp;quot;)
-- 或者是
-- require &amp;quot;&amp;lt;模块名&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。&lt;/p&gt;

&lt;p&gt;或者给加载的模块定义一个别名变量，方便调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local m = require(&amp;quot;module&amp;quot;)
print(m.constant)
m.func3()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。&lt;/p&gt;

&lt;p&gt;require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt;  print(package.path)
~/lua/?.lua;/usr/local/share/lua/5.1/?.lua;/home/huang/workspace/luactor/?.lua;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有 LUA_PATH 这个环境变量，也可以自定义设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ export LUA_PATH=&amp;quot;4;;&amp;quot;
huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ lua
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt;  print(package.path)
4;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua;
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，随便加的环境变量&amp;rdquo;4;&amp;ldquo;写在了package.path中。&lt;/p&gt;

&lt;p&gt;而为什么4需要两个&amp;rsquo;；&amp;rsquo;号呢：文件路径以 &amp;ldquo;;&amp;rdquo; 号分隔，最后的 2 个 &amp;ldquo;;;&amp;rdquo; 表示新加的路径后面加上原来的默认路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ export LUA_PATH=&amp;quot;4;&amp;quot;
huang@ThinkPad-X220:~/workspace/luapkg/luasocket-2.0.2$ lua
Lua 5.1.5  Copyright (C) 1994-2012 Lua.org, PUC-Rio
&amp;gt; print(package.path)
4;
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见如果只有一个；号，将只采用这个分号。&lt;/p&gt;

&lt;p&gt;如果找过目标文件，则会调用 package.loadfile 来加载模块。否则，就会去找 C 程序库。搜索的文件路径是从全局变量 package.cpath 获取，而这个变量则是通过环境变量 LUA_CPATH 来初始。搜索的策略跟上面的一样，只不过现在换成搜索的是 so 或 dll 类型的文件。如果找得到，那么 require 就会通过 package.loadlib 来加载它。&lt;/p&gt;

&lt;p&gt;我们也可以在lua代码中&lt;a href=&#34;https://github.com/rtsisyk/luafun&#34;&gt;动态修改package.path变量&lt;/a&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;package.path = &amp;quot;../?.lua;&amp;quot;..package.path
require &amp;quot;fun&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这点对于我们自己的lua project的设置来说无疑是很方便的。
&lt;a href=&#34;http://www.runoob.com/lua/lua-modules-packages.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;cpp调用c函数:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;cpp调用c函数&lt;/h2&gt;

&lt;p&gt;由于CPP在链接时与C不太一样，因此在调用C函数时，&lt;a href=&#34;http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html&#34;&gt;需要做一定处理。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;将C函数的声明房子 &lt;strong&gt;&lt;em&gt;#ifdef __cplusplus&lt;/em&gt;&lt;/strong&gt; 块中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
 
/*.
 * c functions declarations
..*/

#ifdef __cplusplus
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;多少人在猜你机器的密码呢:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;多少人在猜你机器的密码呢&lt;/h2&gt;

&lt;p&gt;VPS在公网就是个待宰的肥肉，都想去登陆，那&lt;a href=&#34;https://plus.google.com/+AlbertSu2015/posts/Uu1vbeJY1Hw&#34;&gt;都谁猜我的IP了呢？&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo grep &amp;quot;Failed password for root&amp;quot; /var/log/auth.log | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;grep的简单使用-与-或-非:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;grep的简单使用，与 或 非&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;或操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep -E &#39;123|abc&#39; filename  // 找出文件（filename）中包含123或者包含abc的行
egrep &#39;123|abc&#39; filename    // 用egrep同样可以实现
awk &#39;/123|abc/&#39; filename   // awk 的实现方式
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;与操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;其他操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，
grep -l pattern files ：只列出匹配的文件名，
grep -L pattern files ：列出不匹配的文件名，
grep -w pattern files ：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），
grep -v pattern files ：不匹配pattern
grep -C number pattern files ：匹配的上下文分别显示[number]行，
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;iptables的简单使用:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;iptables的简单使用&lt;/h2&gt;

&lt;p&gt;其实并不想写iptables相关的内容，因为用的不熟，但是一些常用的命令还是记一下吧&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://linux.cn/article-1586-1.html&#34;&gt;iptables的详细解释&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Linux系统中,防火墙(Firewall),网址转换(NAT),数据包(package)记录,流量统计,这些功能是由Netfilter子系统所提供的，而iptables是控制Netfilter的工具。iptables将许多复杂的规则组织成成容易控制的方式，以便管理员可以进行分组测试，或关闭、启动某组规则。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;https://blog.phpgao.com/vps_iptables.html
http://www.tabyouto.com/bandwagon-vps-for-shadowsocks-was-hacked.html
http://my.oschina.net/yqc/blog/82111?fromerr=VxVIazGW
http://www.vpser.net/security/linux-iptables.html
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 列出所有规则
iptables -L -n

# 更新iptables规则，规则写在/etc/iptables.rules
iptables-restore &amp;lt; /etc/iptables.rules

# 保存iptables规则，规则写在/etc/iptables.rules
iptables-save &amp;gt; /etc/iptables.rules

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是Debian/Ubuntu上iptables是不会保存规则的。&lt;/p&gt;

&lt;p&gt;需要按如下步骤进行，让网卡关闭是保存iptables规则，启动时加载iptables规则：&lt;/p&gt;

&lt;p&gt;创建/etc/network/if-post-down.d/iptables 文件，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
iptables-save &amp;gt; /etc/iptables.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行：chmod +x /etc/network/if-post-down.d/iptables 添加执行权限。&lt;/p&gt;

&lt;p&gt;创建/etc/network/if-pre-up.d/iptables 文件，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
iptables-restore &amp;lt; /etc/iptables.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行：chmod +x /etc/network/if-pre-up.d/iptables 添加执行权限。&lt;/p&gt;

&lt;p&gt;iptables的一些常用规则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#允许ping
iptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想清空的话，先执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sbin/iptables -P INPUT ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sbin/iptables -F
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vps简单的ssh登陆设置:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;VPS简单的ssh登陆设置&lt;/h2&gt;

&lt;p&gt;初次使用VPS，不懂得安全的重要性，直到扣款时候才心疼，这个时候，弱口令，密码登陆什么的，还是都放弃吧，只用ssh登陆，并且换一个自己的端口。&lt;a href=&#34;https://imququ.com/post/bandwagon-vps-and-basicly-usage.html&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单来说，任何一台主机想登陆VPS的主机都需要有本身的ssh公钥私钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/.ssh/
ssh-keygen -t rsa -C &amp;quot;username@gmail.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后复制~/.ssh/id_rsa.pub中的内容，就是本机的公钥。&lt;/p&gt;

&lt;p&gt;将公钥添加到VPS服务器的/home/username/.ssh/authorized_keys中，本机就能以username用户名登陆VPS了&lt;/p&gt;

&lt;p&gt;然后在/etc/ssh/sshd_config中禁用禁用 VPS 的密码登录和 root 帐号登录，将以下两项改为no&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PasswordAuthentication no
PermitRootLogin no

Port 11111

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随后重启SSH服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo service ssh restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vim删除空行:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;vim删除空行&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;从网页上copy下代码后，发现很多情况下有不想要的空行，非常影响阅读，通过&lt;a href=&#34;http://bbs.chinaunix.net/thread-510754-1-1.html&#34;&gt;vim的正则&lt;/a&gt;可以解决

&lt;ul&gt;
&lt;li&gt;Delete all blank lines (^ is start of line; \s* is zero or more whitespace characters; $ is end of line)&lt;/li&gt;
&lt;li&gt;删除所有空白行(^是行的开始，\s*是零个或者多个空白字符；$是行尾)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;:g/^\s*$/d
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu通过命令设置系统时间:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu通过命令设置系统时间&lt;/h2&gt;

&lt;p&gt;在嵌入式开发中，在pcduino或者rpi板子上安装好linux后，系统时间是UTC时间1970年，对于有些软件来说可能影响安装，所以需要命令行修改date&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo date -s &amp;quot;13 DEC 2015 20:43&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu终端下中文设置:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu终端下中文设置&lt;/h2&gt;

&lt;p&gt;在安装完ubuntu系统后，我们发现中文支持的不好，主要体现在locale的错误，&lt;a href=&#34;http://www.linuxidc.com/Linux/2015-08/122501.htm&#34;&gt;解决方法：&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = (unset),
	LC_ALL = (unset),
	LC_PAPER = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_ADDRESS = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_MONETARY = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_NUMERIC = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_TELEPHONE = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_IDENTIFICATION = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_MEASUREMENT = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_TIME = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LC_NAME = &amp;quot;zh_CN.UTF-8&amp;quot;,
	LANG = &amp;quot;en_US.UTF-8&amp;quot;
    are supported and installed on your system.
perl: warning: Falling back to the standard locale (&amp;quot;C&amp;quot;).

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为中文包没有安装好的缘故，如下命令就可以解决：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;添加简体中文支持
sudo apt-get -y install language-pack-zh-hans language-pack-zh-hans-base

添加繁体中文支持
sudo apt-get -y install language-pack-zh-hant language-pack-zh-hant-base

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果还不行，先观察下locale的配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@localhost:~$ locale
locale: Cannot set LC_CTYPE to default locale: No such file or directory
locale: Cannot set LC_MESSAGES to default locale: No such file or directory
locale: Cannot set LC_ALL to default locale: No such file or directory
LANG=en_US.UTF-8
LANGUAGE=
LC_CTYPE=&amp;quot;en_US.UTF-8&amp;quot;
LC_NUMERIC=zh_CN.UTF-8
LC_TIME=zh_CN.UTF-8
LC_COLLATE=&amp;quot;en_US.UTF-8&amp;quot;
LC_MONETARY=zh_CN.UTF-8
LC_MESSAGES=&amp;quot;en_US.UTF-8&amp;quot;
LC_PAPER=zh_CN.UTF-8
LC_NAME=zh_CN.UTF-8
LC_ADDRESS=zh_CN.UTF-8
LC_TELEPHONE=zh_CN.UTF-8
LC_MEASUREMENT=zh_CN.UTF-8
LC_IDENTIFICATION=zh_CN.UTF-8
LC_ALL=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再重新配置下语言包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;huang@localhost:~$  sudo locale-gen &amp;quot;en_US.UTF-8&amp;quot;
Generating locales...
  en_US.UTF-8... done
Generation complete.
huang@localhost:~$ sudo  pip install shadowsocks^C
huang@localhost:~$  sudo locale-gen &amp;quot;zh_CN.UTF-8&amp;quot;
Generating locales...
  zh_CN.UTF-8... done
Generation complete.
huang@localhost:~$ sudo dpkg-reconfigure locales
Generating locales...
  en_US.UTF-8... done
  zh_CN.UTF-8... up-to-date
  zh_HK.UTF-8... done
  zh_SG.UTF-8... done
  zh_TW.UTF-8... done
Generation complete.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般就都能解决&lt;/p&gt;

&lt;h2 id=&#34;linux终端下的颜色设置输出:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;Linux终端下的颜色设置输出&lt;/h2&gt;

&lt;p&gt;Linux终端下，如果有一个彩色的终端，可以明显提升人的阅读兴趣，通过printf的简单设置即可&lt;a href=&#34;http://www.w2bc.com/Article/39141&#34;&gt;实现彩色输出&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;\033[显示方式;前景色;背景色m

    显示方式、前景色、背景色至少一个存在即可。
    格式：\033[显示方式;前景色;背景色m
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;前景色  背景色  颜色
30  40  黑色
31  41  红色
32  42  绿色
33  43  黃色
34  44  蓝色
35  45  紫红色
36  46  青蓝色
37  47  白色


显示方式    意义
0   终端默认设置
1   高亮显示
4   使用下划线
5   闪烁
7   反白显示
8   不可见

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;\033[1;31;40m    &amp;lt;!--1-高亮显示 31-前景色红色  40-背景色黑色--&amp;gt;
\033[0m          &amp;lt;!--采用终端默认设置，即取消颜色设置--&amp;gt;

printf(&amp;quot;\033[1;31;40m&amp;quot;);
printf(&amp;quot;\033[0m&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tsar监控系统负载和nginx运行情况:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;tsar监控系统负载和nginx运行情况&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/alibaba/tsar&#34;&gt;tsar&lt;/a&gt;是阿里巴巴发布的一款能够实时监控系统状态的命令行工具，并且支持第三方模块扩展，其中比较注明的是nginx模块。使用tsar时，可以将系统负载和nginx运行情况同步同时打出，可以用来定位系统瓶颈，所以广受好评。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;tsar -li1&lt;/em&gt;&lt;/strong&gt; 是其最经典的用法，可以将一般我们感兴趣的监控项每秒更新一次并输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Time              ---cpu-- ---mem-- ---tcp-- -----traffic---- --sda---  ---load- 
Time                util     util   retran    bytin  bytout     util     load1   
25/03/16-19:03:30   0.08    10.22     0.00     1.4K    1.2K     0.00     0.33  
25/03/16-19:03:31   0.08    10.21     0.00   424.00  468.00     0.00     0.33   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想使能nginx模块，需要对其进行配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. mkdir /etc/tsar/conf.d
2. touch /etc/tsar/conf.d/nginx.conf

3. 写入如下内容并保存
mod_nginx on

####add it to tsar default output
output_stdio_mod mod_nginx

####add it to center db
#output_db_mod mod_nginx

####add it to nagios send
####set nagios threshold for alert
#output_nagios_mod mod_nginx

#threshold nginx.value1;N;N;N;N;
#threshold nginx.value2;N;N;N;N;
#threshold nginx.value3;N;N;N;N;

表示使能nginx模块，并使用stdio输出

4. tsar -li1

Time              ---cpu-- ---mem-- ---tcp-- -----traffic---- --sda---  ---load- ------------------nginx----------------- 
Time                util     util   retran    bytin  bytout     util     load1      qps      rt  sslqps  spdyps  sslhst   
25/03/16-19:06:19   0.08    11.40     7.14   302.00  546.00     0.00     0.02     1.00    0.00    0.00    0.00    0.00   

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wrk在centos系统上的编译方法:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;wrk在CentOS系统上的编译方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/wg/wrk&#34;&gt;wrk&lt;/a&gt;作为一款可以内嵌lua脚本的，支持多线程的压测工具，受到了广泛欢迎。在高版本CentOS 7上，直接在wrk目录下执行make，可以首先编译deps/luajit，得到deps/luajit/libluajit.a，然而在低版本上，CentOS 6.5系统中，会报一些莫名奇妙的错误。&lt;/p&gt;

&lt;p&gt;解决方法是，查看wrk的Makefile，发现wrk依赖于luajit，那么首先进入deps/luajit编译它，并且是静态编译&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd wrk
cd deps/luajit
make -j24 BUILDMODE=static

cd ../..
make -j24

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rpmbuild环境的快速初始化:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;rpmbuild环境的快速初始化&lt;/h2&gt;

&lt;p&gt;需要将代码打包为CentOS的RPM包时，可以先自己在本地新建一个环境&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. mkdir -p ~/rpmbuild/{SOURCES,BUILD,BUILDROOT,RPMS,SRPMS,SPECS}
2. 将代打包的代码压缩包 software.tar.gz 放入SOURCES文件夹
3. 将 software.spec 放入SPECS文件夹
4. rpmbuild -ba path/to/software.spec 即可
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git记住密码-不用每次都输密码才登入:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git记住密码，不用每次都输密码才登入&lt;/h2&gt;

&lt;p&gt;git有两种方式，一种是ssh方式，配置公钥私钥，对于新手而言还是比较麻烦的；另一种是http方式，这里有一个办法可以让git记住密码，避免每次都需要输入密码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;1. touch ~/.git-credentials
2. 将  https://{username}:{password}@github.com  写入该文件
3. git config --global credential.helper store  就可以使得git记住密码了
4. 此时查看 ~/.gitconfig，发现多了一项
    
    [credential] 
    helper = store 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;centos系统上某些软件-比如gcc-python等版本过低的解决方案:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;centos系统上某些软件，比如gcc、python等版本过低的解决方案&lt;/h2&gt;

&lt;p&gt;在CentOS Server上，经常会遇到某些软件依赖版本过低的问题，比如CentOS 6.5的python是2.7版本的，gcc是4.2版本的，那么我们如何获得一个干净的、与原版本无冲突的运行环境呢。CentOS系提供了一个叫SCL的工具，可以帮我们实现目的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo wget http://people.centos.org/tru/devtools-1.1/devtools-1.1.repo -P /etc/yum.repos.d
$ sudo sh -c &#39;echo &amp;quot;enabled=1&amp;quot; &amp;gt;&amp;gt; /etc/yum.repos.d/devtools-1.1.repo&#39;
$ sudo yum install devtoolset-1.1
$ scl enable devtoolset-1.1 bash
$ gcc --version
# 通过devtoolset工具可以暂时提高gcc版本，而不更改之前服务器的配置，这个很有效果，高版本的gcc会智能保留symbol。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# CentOS 6.5
sudo yum install centos-release-SCL
sudo yum install python27
scl enable python27 bash
python --version
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ubuntu系统上某些软件-比如gcc等版本过高的解决方案:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;ubuntu系统上某些软件，比如gcc等版本过高的解决方案&lt;/h2&gt;

&lt;p&gt;与CentOS相反，debian系发行版的软件版本都很高，Ubuntu 16.04的gcc 版本已经到了5.2，然而编译一些早期linux内核的话，需要gcc-4.7左右的版本，这时候我们怎么办呢，有两个方法：
* 通过apt安装低版本gcc
    * sudo apt-get install gcc-4.7
    * 在编译linux 内核时， make CC=gcc-4.7 即可
* update-alternatives可以帮忙更改符号链接，指向不同版本的gcc
    * &lt;a href=&#34;http://www.metsky.com/archives/607.html&#34;&gt;参考链接1&lt;/a&gt;
    * &lt;a href=&#34;http://blog.csdn.net/zyxlinux888/article/details/6708775&#34;&gt;参考链接2&lt;/a&gt; &lt;a href=&#34;http://blog.csdn.net/zyxlinux888/article/details/6709036&#34;&gt;附赠&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python的matplotlib库实现绘制图标:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;python的matplotlib库实现绘制图标&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;sudo apt-get install python-matplotlib&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://matplotlib.org/index.html&#34;&gt;参考链接&lt;/a&gt;
&lt;a href=&#34;http://matplotlib.org/examples/index.html&#34;&gt;example&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python使用requests库发送http请求:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;python使用requests库发送http请求&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://cn.python-requests.org/zh_CN/latest/user/quickstart.html#json&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;python解析命令行参数-argparse:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;python解析命令行参数：argparse&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.xiayf.cn/2013/03/30/argparse/&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;git比较两次commit的差异:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git比较两次commit的差异&lt;/h2&gt;

&lt;p&gt;通过比较两次commit的代码差异，能够快速理解此次commit的目的，理解作者意图&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;git log

&lt;ul&gt;
&lt;li&gt;查看commit历史&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;commit 2279c3f4a8a42e696a0f34e6e9b6289487da92c1
Author: bg2bkk &amp;lt;bg2bkk@gmail.com&amp;gt;
Date:   Sun Mar 13 09:12:26 2016 +0800

    add SO_REUSEADDR和SO_REUSEPORT.md

commit 2b9d85f8427c5ca9e4f9c128c22acd280eb94405
Author: bg2bkk &amp;lt;bg2bkk@gmail.com&amp;gt;
Date:   Sat Mar 12 01:16:00 2016 +0800

    add 采用二级指针实现单链表操作 单链表翻转 删除单链表结点
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;git diff commit 2279c3f4a8a42e696a0f34e6e9b6289487da92c1 2b9d85f8427c5ca9e4f9c128c22acd280eb94405&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git返回强制返回某次提交:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;git返回强制返回某次提交&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;git log&lt;/li&gt;
&lt;li&gt;git reset 5f4769a98985b5acfea45462df27830e51a75145 &amp;ndash;hard

&lt;ul&gt;
&lt;li&gt;可见commit号很重要&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;iptables允许端口被外网访问:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;iptables允许端口被外网访问&lt;/h2&gt;

&lt;p&gt;防火墙设置，配置1985端口可以被外网访问&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sudo iptables -A INPUT -m state &amp;ndash;state NEW -m tcp -p tcp &amp;ndash;dport 1985 -j ACCEPT&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcpdump过滤指定标志的packet:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;tcpdump过滤指定标志的packet&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# tcp包里有个flags字段表示包的类型，tcpdump可以根据该字段抓取相应类型的包：
# tcp[13] 就是 TCP flags (URG,ACK,PSH,RST,SYN,FIN)
# Unskilled 32
# Attackers 16
# Pester     8
# Real       4
# Security   2
# Folks      1

#抓取fin包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 1 != 0 &#39; -s0  -w fin.cap -vvv
#抓取syn+fin包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 3 != 0 &#39; -s0  -w syn_fin.cap -vvv
#抓取rst包：
tcpdump -ni any port 9001 and &#39;tcp[13] &amp;amp; 4 != 0 &#39; -s0  -w rst.cap -vvv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://babyhe.blog.51cto.com/1104064/1395489&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看进程的内存占用情况:1350fa5c56171e9d9c8991f08929cd14&#34;&gt;查看进程的内存占用情况&lt;/h2&gt;

&lt;p&gt;用Ternary Search Tree代替Trie Tree后，我想知道我的进程内存占用有多大区别。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ps -e -o &amp;lsquo;pid,comm,args,pcpu,rsz,vsz,stime,user,uid&amp;rsquo; | grep MyDict&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;rsz是实际占用内存，单位是KB&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pmap -d pid&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>